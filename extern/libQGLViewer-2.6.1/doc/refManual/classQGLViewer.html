<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>libQGLViewer: QGLViewer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link rel="shortcut icon" href="../images/qglviewer.ico" type="image/x-icon" />
<link rel="icon" href="../images/qglviewer.icon.png" type="image/png" />
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libQGLViewer
   &#160;<span id="projectnumber">Version 2.6.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classQGLViewer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">QGLViewer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A versatile 3D OpenGL viewer based on QGLWidget.  
 <a href="classQGLViewer.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a252b68caec768d882a3fa78ecd1499db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a252b68caec768d882a3fa78ecd1499db">viewerInitialized</a> ()</td></tr>
<tr class="separator:a252b68caec768d882a3fa78ecd1499db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a712ca70a0b1c22af51363b786fc86e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a7a712ca70a0b1c22af51363b786fc86e">drawNeeded</a> ()</td></tr>
<tr class="separator:a7a712ca70a0b1c22af51363b786fc86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc74e28548768da157f2fe75bced2803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#afc74e28548768da157f2fe75bced2803">drawFinished</a> (bool automatic)</td></tr>
<tr class="separator:afc74e28548768da157f2fe75bced2803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841503c97db5a51e33f8a7e56d4ca006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a841503c97db5a51e33f8a7e56d4ca006">animateNeeded</a> ()</td></tr>
<tr class="separator:a841503c97db5a51e33f8a7e56d4ca006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f461121859dc0c19e7af2d413935e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a64f461121859dc0c19e7af2d413935e0">helpRequired</a> ()</td></tr>
<tr class="separator:a64f461121859dc0c19e7af2d413935e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541cdbec67d0c5895cd6c77c01b0f89e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a541cdbec67d0c5895cd6c77c01b0f89e">axisIsDrawnChanged</a> (bool drawn)</td></tr>
<tr class="separator:a541cdbec67d0c5895cd6c77c01b0f89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d191cc46db491d9807266fe62b6178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a02d191cc46db491d9807266fe62b6178">gridIsDrawnChanged</a> (bool drawn)</td></tr>
<tr class="separator:a02d191cc46db491d9807266fe62b6178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b005fb3bda4582ce4ab7aeda6692699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a4b005fb3bda4582ce4ab7aeda6692699">FPSIsDisplayedChanged</a> (bool displayed)</td></tr>
<tr class="separator:a4b005fb3bda4582ce4ab7aeda6692699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b30c0de291a24af638e8c1d6171943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ac0b30c0de291a24af638e8c1d6171943">textIsEnabledChanged</a> (bool enabled)</td></tr>
<tr class="separator:ac0b30c0de291a24af638e8c1d6171943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38968d2f050efa14869c2e4de416b7b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a38968d2f050efa14869c2e4de416b7b4">cameraIsEditedChanged</a> (bool edited)</td></tr>
<tr class="separator:a38968d2f050efa14869c2e4de416b7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7df8ab7c351e32da3c72b19c4585c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a9d7df8ab7c351e32da3c72b19c4585c0">stereoChanged</a> (bool on)</td></tr>
<tr class="separator:a9d7df8ab7c351e32da3c72b19c4585c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78f96913c9aede4854b0efccf53f983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ab78f96913c9aede4854b0efccf53f983">pointSelected</a> (const QMouseEvent *e)</td></tr>
<tr class="separator:ab78f96913c9aede4854b0efccf53f983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959ca6df1731d57aa692af99abcd28d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a959ca6df1731d57aa692af99abcd28d1">mouseGrabberChanged</a> (<a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *<a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber</a>)</td></tr>
<tr class="separator:a959ca6df1731d57aa692af99abcd28d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5cfffe102b268c9af761c5d82a694dcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5cfffe102b268c9af761c5d82a694dcc">QGLViewer</a> (QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WindowFlags flags=0)</td></tr>
<tr class="separator:a5cfffe102b268c9af761c5d82a694dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724b62429d2ecd9049bc41a562901b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a4724b62429d2ecd9049bc41a562901b6">QGLViewer</a> (QGLContext *context, QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WindowFlags flags=0)</td></tr>
<tr class="separator:a4724b62429d2ecd9049bc41a562901b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b655fa44abb36439e4f7ef3ad2cd649"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5b655fa44abb36439e4f7ef3ad2cd649">QGLViewer</a> (const QGLFormat &amp;format, QWidget *parent=0, const QGLWidget *shareWidget=0, Qt::WindowFlags flags=0)</td></tr>
<tr class="separator:a5b655fa44abb36439e4f7ef3ad2cd649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c90239e64b7a43473a189d5da865ac7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a8c90239e64b7a43473a189d5da865ac7">~QGLViewer</a> ()</td></tr>
<tr class="separator:a8c90239e64b7a43473a189d5da865ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Display of visual hints</h2></td></tr>
<tr class="memitem:a7d38e6f11078e886f7978525def15797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a7d38e6f11078e886f7978525def15797">axisIsDrawn</a> () const </td></tr>
<tr class="separator:a7d38e6f11078e886f7978525def15797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee18c56a8321a60771b085a5fe798ee7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aee18c56a8321a60771b085a5fe798ee7">gridIsDrawn</a> () const </td></tr>
<tr class="separator:aee18c56a8321a60771b085a5fe798ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8985b86aca5584d9869c8ac868984a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed</a> () const </td></tr>
<tr class="separator:a4b8985b86aca5584d9869c8ac868984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87896d67f84ddb458e1e5ab326db2631"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a87896d67f84ddb458e1e5ab326db2631">textIsEnabled</a> () const </td></tr>
<tr class="separator:a87896d67f84ddb458e1e5ab326db2631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf2817fb27f0ad326e3db75aeb46af7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited</a> () const </td></tr>
<tr class="separator:a1bf2817fb27f0ad326e3db75aeb46af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be8cff3702c1a130f8a17330737a887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5be8cff3702c1a130f8a17330737a887">setAxisIsDrawn</a> (bool <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw</a>=true)</td></tr>
<tr class="separator:a5be8cff3702c1a130f8a17330737a887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dd114195dfdf82e23b5754b7c161de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae9dd114195dfdf82e23b5754b7c161de">setGridIsDrawn</a> (bool <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw</a>=true)</td></tr>
<tr class="separator:ae9dd114195dfdf82e23b5754b7c161de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad24c89e014de3ea16f071c3bc18f4db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aad24c89e014de3ea16f071c3bc18f4db">setFPSIsDisplayed</a> (bool display=true)</td></tr>
<tr class="separator:aad24c89e014de3ea16f071c3bc18f4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d76caa402acd217e504d0bcd13e421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a73d76caa402acd217e504d0bcd13e421">setTextIsEnabled</a> (bool enable=true)</td></tr>
<tr class="separator:a73d76caa402acd217e504d0bcd13e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521c83b1d745b37331932b4d7b976d41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a521c83b1d745b37331932b4d7b976d41">setCameraIsEdited</a> (bool edit=true)</td></tr>
<tr class="separator:a521c83b1d745b37331932b4d7b976d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2ccb8a346c04a5c7da87da0e8e601f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#acf2ccb8a346c04a5c7da87da0e8e601f">toggleAxisIsDrawn</a> ()</td></tr>
<tr class="separator:acf2ccb8a346c04a5c7da87da0e8e601f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfaa8be71152ae881b9347235ccc6a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a8dfaa8be71152ae881b9347235ccc6a1">toggleGridIsDrawn</a> ()</td></tr>
<tr class="separator:a8dfaa8be71152ae881b9347235ccc6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a88948237894dca2b7b57a67226d66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ab8a88948237894dca2b7b57a67226d66">toggleFPSIsDisplayed</a> ()</td></tr>
<tr class="separator:ab8a88948237894dca2b7b57a67226d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92b2b41db85e4347675b0bc453366d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ab92b2b41db85e4347675b0bc453366d7">toggleTextIsEnabled</a> ()</td></tr>
<tr class="separator:ab92b2b41db85e4347675b0bc453366d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a53b30eacfccf0825b808977d634936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3a53b30eacfccf0825b808977d634936">toggleCameraIsEdited</a> ()</td></tr>
<tr class="separator:a3a53b30eacfccf0825b808977d634936"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Viewer's colors</h2></td></tr>
<tr class="memitem:a7ddf68dcfb09cc5a991a06d91cb4cc5b"><td class="memItemLeft" align="right" valign="top">QColor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a7ddf68dcfb09cc5a991a06d91cb4cc5b">backgroundColor</a> () const </td></tr>
<tr class="separator:a7ddf68dcfb09cc5a991a06d91cb4cc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f726def3615050a9c816c0ca32171d"><td class="memItemLeft" align="right" valign="top">QColor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aa2f726def3615050a9c816c0ca32171d">foregroundColor</a> () const </td></tr>
<tr class="separator:aa2f726def3615050a9c816c0ca32171d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d4e21190fdc47edd88f078dd2037cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a70d4e21190fdc47edd88f078dd2037cb">setBackgroundColor</a> (const QColor &amp;color)</td></tr>
<tr class="separator:a70d4e21190fdc47edd88f078dd2037cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d986b1944dc5a190e509835e7c79eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a7d986b1944dc5a190e509835e7c79eec">setForegroundColor</a> (const QColor &amp;color)</td></tr>
<tr class="separator:a7d986b1944dc5a190e509835e7c79eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Scene dimensions</h2></td></tr>
<tr class="memitem:a32b418de3796a253b28c9635b2f4f6fb"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius</a> () const </td></tr>
<tr class="separator:a32b418de3796a253b28c9635b2f4f6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0503bc22a710f96bfd779eaf538bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">sceneCenter</a> () const </td></tr>
<tr class="separator:a5a0503bc22a710f96bfd779eaf538bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5138140e12f0fdcf7370b9c6d85eedd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ad5138140e12f0fdcf7370b9c6d85eedd">setSceneRadius</a> (qreal radius)</td></tr>
<tr class="separator:ad5138140e12f0fdcf7370b9c6d85eedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712acd05f9d518d6babfe96e537d06d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a6712acd05f9d518d6babfe96e537d06d">setSceneCenter</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;center)</td></tr>
<tr class="separator:a6712acd05f9d518d6babfe96e537d06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8339148d876e633c27e5df826f06c9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aa8339148d876e633c27e5df826f06c9c">setSceneBoundingBox</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;min, const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;max)</td></tr>
<tr class="separator:aa8339148d876e633c27e5df826f06c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8dd7d2346ebf46ed1f9822a8418df2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene</a> ()</td></tr>
<tr class="separator:ada8dd7d2346ebf46ed1f9822a8418df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Associated objects</h2></td></tr>
<tr class="memitem:a27a9e97573822d296b48e1c408b74042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera</a> () const </td></tr>
<tr class="separator:a27a9e97573822d296b48e1c408b74042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8c9c519574192fb7197bdbad8049db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame</a> () const </td></tr>
<tr class="separator:aba8c9c519574192fb7197bdbad8049db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c45e1d2c4777de28664d3db952b7585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a9c45e1d2c4777de28664d3db952b7585">setCamera</a> (<a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *const <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera</a>)</td></tr>
<tr class="separator:a9c45e1d2c4777de28664d3db952b7585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6964ec1ebb2f42464313e0c43e767a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ac6964ec1ebb2f42464313e0c43e767a3">setManipulatedFrame</a> (<a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *frame)</td></tr>
<tr class="separator:ac6964ec1ebb2f42464313e0c43e767a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mouse grabbers</h2></td></tr>
<tr class="memitem:a6c834adafd727025b63741dd27cb6925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber</a> () const </td></tr>
<tr class="separator:a6c834adafd727025b63741dd27cb6925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0b956f948f469c095ff3c2c1b73494"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3f0b956f948f469c095ff3c2c1b73494">setMouseGrabberIsEnabled</a> (const <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *const <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber</a>, bool enabled=true)</td></tr>
<tr class="separator:a3f0b956f948f469c095ff3c2c1b73494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe9b0a1fcd39a5cb132ffdc86f2574f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5fe9b0a1fcd39a5cb132ffdc86f2574f">mouseGrabberIsEnabled</a> (const <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *const <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber</a>)</td></tr>
<tr class="separator:a5fe9b0a1fcd39a5cb132ffdc86f2574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993285ef8a16ccbdc5d57a1264212712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a993285ef8a16ccbdc5d57a1264212712">setMouseGrabber</a> (<a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *<a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber</a>)</td></tr>
<tr class="separator:a993285ef8a16ccbdc5d57a1264212712"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
State of the viewer</h2></td></tr>
<tr class="memitem:a06471e2ca19ce8da106ee4b996687b01"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a06471e2ca19ce8da106ee4b996687b01">aspectRatio</a> () const </td></tr>
<tr class="separator:a06471e2ca19ce8da106ee4b996687b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d52227793dba3e2f87f07acec26fd56"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a6d52227793dba3e2f87f07acec26fd56">currentFPS</a> ()</td></tr>
<tr class="separator:a6d52227793dba3e2f87f07acec26fd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129c439f36bb669672148192abc8ffed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a129c439f36bb669672148192abc8ffed">isFullScreen</a> () const </td></tr>
<tr class="separator:a129c439f36bb669672148192abc8ffed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc4c62e317a0f64c2a943ed11faa337"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo</a> () const </td></tr>
<tr class="separator:a2fc4c62e317a0f64c2a943ed11faa337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8288a17cf54658f1ce1c0db9e97dc8a"><td class="memItemLeft" align="right" valign="top">virtual QSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ad8288a17cf54658f1ce1c0db9e97dc8a">sizeHint</a> () const </td></tr>
<tr class="separator:ad8288a17cf54658f1ce1c0db9e97dc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e021e15180ba348e90c955bdd28b1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a7e021e15180ba348e90c955bdd28b1a4">setFullScreen</a> (bool fullScreen=true)</td></tr>
<tr class="separator:a7e021e15180ba348e90c955bdd28b1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe362ba5c3851a93f23fb833b2479f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#afe362ba5c3851a93f23fb833b2479f08">setStereoDisplay</a> (bool stereo=true)</td></tr>
<tr class="separator:afe362ba5c3851a93f23fb833b2479f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b47397e4ad7c2bb9573e0d186170e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aa5b47397e4ad7c2bb9573e0d186170e0">toggleFullScreen</a> ()</td></tr>
<tr class="separator:aa5b47397e4ad7c2bb9573e0d186170e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0ebf98eacbcbad3b094e26d9e35886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a4e0ebf98eacbcbad3b094e26d9e35886">toggleStereoDisplay</a> ()</td></tr>
<tr class="separator:a4e0ebf98eacbcbad3b094e26d9e35886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ea00dd30fb78086cf7e22bc2f10695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a17ea00dd30fb78086cf7e22bc2f10695">toggleCameraMode</a> ()</td></tr>
<tr class="separator:a17ea00dd30fb78086cf7e22bc2f10695"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Display methods</h2></td></tr>
<tr class="memitem:a5825ac26bdef13ae5ddd021e318aaf15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem</a> (bool upward=false) const </td></tr>
<tr class="separator:a5825ac26bdef13ae5ddd021e318aaf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cff22af974391604bff7f91df789138"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a9cff22af974391604bff7f91df789138">stopScreenCoordinatesSystem</a> () const </td></tr>
<tr class="separator:a9cff22af974391604bff7f91df789138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad604ec747b161c869877fcb647a3c775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText</a> (int x, int y, const QString &amp;text, const QFont &amp;fnt=QFont())</td></tr>
<tr class="separator:ad604ec747b161c869877fcb647a3c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61336516f9771ac6aef90875f848add4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a61336516f9771ac6aef90875f848add4">displayMessage</a> (const QString &amp;message, int delay=2000)</td></tr>
<tr class="separator:a61336516f9771ac6aef90875f848add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee5a2d40e4613eb6c824311e01ce150"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3ee5a2d40e4613eb6c824311e01ce150">drawArrow</a> (qreal length=1.0, qreal radius=-1.0, int nbSubdivisions=12)</td></tr>
<tr class="separator:a3ee5a2d40e4613eb6c824311e01ce150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3e50e3881dca15e1b9641afa0054dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a4d3e50e3881dca15e1b9641afa0054dc">drawArrow</a> (const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;from, const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;to, qreal radius=-1.0, int nbSubdivisions=12)</td></tr>
<tr class="separator:a4d3e50e3881dca15e1b9641afa0054dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3072ee7495b54d48d1a11a5bd02a25cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3072ee7495b54d48d1a11a5bd02a25cc">drawAxis</a> (qreal length=1.0)</td></tr>
<tr class="separator:a3072ee7495b54d48d1a11a5bd02a25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a359ff8c78755fca0900321293da8f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a86a359ff8c78755fca0900321293da8f">drawGrid</a> (qreal size=1.0, int nbSubdivisions=10)</td></tr>
<tr class="separator:a86a359ff8c78755fca0900321293da8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f54947331c56ea1a2de82ecba70b07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae8f54947331c56ea1a2de82ecba70b07">drawLight</a> (GLenum light, qreal scale=1.0) const </td></tr>
<tr class="separator:ae8f54947331c56ea1a2de82ecba70b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Useful inherited methods</h2></td></tr>
<tr class="memitem:a369399896761e31ae71db57fdd0ba431"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width</a> () const </td></tr>
<tr class="separator:a369399896761e31ae71db57fdd0ba431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26bcfe2f33f5873dbdfb6948cf1f59f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height</a> () const </td></tr>
<tr class="separator:ae26bcfe2f33f5873dbdfb6948cf1f59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12b7378efbffabc24a133ca1deb19ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae12b7378efbffabc24a133ca1deb19ae">updateGL</a> ()</td></tr>
<tr class="separator:ae12b7378efbffabc24a133ca1deb19ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8911f3aec33c17d1eba4390436b5c868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a8911f3aec33c17d1eba4390436b5c868">qglColor</a> (const QColor &amp;color) const </td></tr>
<tr class="separator:a8911f3aec33c17d1eba4390436b5c868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b363f05e720484cde551d5f798e69b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a88b363f05e720484cde551d5f798e69b">qglClearColor</a> (const QColor &amp;color) const </td></tr>
<tr class="separator:a88b363f05e720484cde551d5f798e69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1b70a2ed67ead038c4d3f5ac4d8a81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aac1b70a2ed67ead038c4d3f5ac4d8a81">isValid</a> () const </td></tr>
<tr class="separator:aac1b70a2ed67ead038c4d3f5ac4d8a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514d24ec3ec6c94657ef302a2b3fa74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a514d24ec3ec6c94657ef302a2b3fa74a">isSharing</a> () const </td></tr>
<tr class="separator:a514d24ec3ec6c94657ef302a2b3fa74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1436277e13026c94601bbe37a2f1d262"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a1436277e13026c94601bbe37a2f1d262">makeCurrent</a> ()</td></tr>
<tr class="separator:a1436277e13026c94601bbe37a2f1d262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c0968a61bcd23c491817631e4ec953"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a47c0968a61bcd23c491817631e4ec953">hasMouseTracking</a> () const </td></tr>
<tr class="separator:a47c0968a61bcd23c491817631e4ec953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1185e99a9efec124b7a9bede84a6cf1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ad1185e99a9efec124b7a9bede84a6cf1">resize</a> (int <a class="el" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width</a>, int <a class="el" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height</a>)</td></tr>
<tr class="separator:ad1185e99a9efec124b7a9bede84a6cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0a4ee197fe91b8c07dd74cad1aafaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#acf0a4ee197fe91b8c07dd74cad1aafaa">setMouseTracking</a> (bool enable)</td></tr>
<tr class="separator:acf0a4ee197fe91b8c07dd74cad1aafaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75679575b3b071cddce2a56c77e1bd68"><td class="memItemLeft" align="right" valign="top">static QImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a75679575b3b071cddce2a56c77e1bd68">convertToGLFormat</a> (const QImage &amp;image)</td></tr>
<tr class="separator:a75679575b3b071cddce2a56c77e1bd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36faca915c37548a53ab04f297bb5c17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a36faca915c37548a53ab04f297bb5c17">autoBufferSwap</a> () const </td></tr>
<tr class="separator:a36faca915c37548a53ab04f297bb5c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95e0ffd255bcc1fb69c9213d8d8b017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ad95e0ffd255bcc1fb69c9213d8d8b017">setAutoBufferSwap</a> (bool on)</td></tr>
<tr class="separator:ad95e0ffd255bcc1fb69c9213d8d8b017"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Snapshots</h2></td></tr>
<tr class="memitem:a00f2094711c7349fe1f74b6fc0b5530f"><td class="memItemLeft" align="right" valign="top">const QString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName</a> () const </td></tr>
<tr class="separator:a00f2094711c7349fe1f74b6fc0b5530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb1add55632dced395e2f1b78ef491c"><td class="memItemLeft" align="right" valign="top">const QString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#abbb1add55632dced395e2f1b78ef491c">snapshotFormat</a> () const </td></tr>
<tr class="separator:abbb1add55632dced395e2f1b78ef491c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de825bb96eba2c5f6a55facb9dc4cef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter</a> () const </td></tr>
<tr class="separator:a4de825bb96eba2c5f6a55facb9dc4cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50685165e76c57dc87dea3c84b7e5be0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a50685165e76c57dc87dea3c84b7e5be0">snapshotQuality</a> ()</td></tr>
<tr class="separator:a50685165e76c57dc87dea3c84b7e5be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5568ae9e5539cf410ef369dba7cec5"><td class="memItemLeft" align="right" valign="top">QFont&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a7c5568ae9e5539cf410ef369dba7cec5">scaledFont</a> (const QFont &amp;font) const </td></tr>
<tr class="separator:a7c5568ae9e5539cf410ef369dba7cec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf2ffb973b096b249dc7e90327a2a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot</a> (bool automatic=true, bool overwrite=false)</td></tr>
<tr class="separator:a1cf2ffb973b096b249dc7e90327a2a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82544567565cfa0b750cb24ac1aa8358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a82544567565cfa0b750cb24ac1aa8358">saveSnapshot</a> (const QString &amp;fileName, bool overwrite=false)</td></tr>
<tr class="separator:a82544567565cfa0b750cb24ac1aa8358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15be68d137eca013942eae69e40e0ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aa15be68d137eca013942eae69e40e0ee">setSnapshotFileName</a> (const QString &amp;name)</td></tr>
<tr class="separator:aa15be68d137eca013942eae69e40e0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82043998256d08163f79ceee83278e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a82043998256d08163f79ceee83278e14">setSnapshotFormat</a> (const QString &amp;format)</td></tr>
<tr class="separator:a82043998256d08163f79ceee83278e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb307bbd1a56cdfb3749f699d4af03c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#afeb307bbd1a56cdfb3749f699d4af03c">setSnapshotCounter</a> (int counter)</td></tr>
<tr class="separator:afeb307bbd1a56cdfb3749f699d4af03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64b04b76b1f35ee1b3f07fa747dc9a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ab64b04b76b1f35ee1b3f07fa747dc9a0">setSnapshotQuality</a> (int quality)</td></tr>
<tr class="separator:ab64b04b76b1f35ee1b3f07fa747dc9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c409fd034bc5ab42aacfa4c23fe55c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ac9c409fd034bc5ab42aacfa4c23fe55c">openSnapshotFormatDialog</a> ()</td></tr>
<tr class="separator:ac9c409fd034bc5ab42aacfa4c23fe55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6054c5da7cfd763db7c0b214026a50ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a6054c5da7cfd763db7c0b214026a50ec">snapshotToClipboard</a> ()</td></tr>
<tr class="separator:a6054c5da7cfd763db7c0b214026a50ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Buffer to texture</h2></td></tr>
<tr class="memitem:a6435e0a64e14d04dce25e524051f8d69"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a6435e0a64e14d04dce25e524051f8d69">bufferTextureId</a> () const </td></tr>
<tr class="separator:a6435e0a64e14d04dce25e524051f8d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d083b81d5799f5a7ec768117b9f4a2"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aa7d083b81d5799f5a7ec768117b9f4a2">bufferTextureMaxU</a> () const </td></tr>
<tr class="separator:aa7d083b81d5799f5a7ec768117b9f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accce92c989155aebccfb5dc05c2b8bf9"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#accce92c989155aebccfb5dc05c2b8bf9">bufferTextureMaxV</a> () const </td></tr>
<tr class="separator:accce92c989155aebccfb5dc05c2b8bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1721bfb1c032ae68665808bb2f4453"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aeb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture</a> (GLint internalFormat, GLenum format=GL_NONE)</td></tr>
<tr class="separator:aeb1721bfb1c032ae68665808bb2f4453"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Animation</h2></td></tr>
<tr class="memitem:ad865668850fb0aa249e79f21d2e9d40e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted</a> () const </td></tr>
<tr class="separator:ad865668850fb0aa249e79f21d2e9d40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700d9398d4293d9274766efa8b17917e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a700d9398d4293d9274766efa8b17917e">animationPeriod</a> () const </td></tr>
<tr class="separator:a700d9398d4293d9274766efa8b17917e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37d4e0afe6a47e8f4f828ed41072176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aa37d4e0afe6a47e8f4f828ed41072176">setAnimationPeriod</a> (int period)</td></tr>
<tr class="separator:aa37d4e0afe6a47e8f4f828ed41072176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5344a5f702678f309fafa0c699b2cf3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ad5344a5f702678f309fafa0c699b2cf3">startAnimation</a> ()</td></tr>
<tr class="separator:ad5344a5f702678f309fafa0c699b2cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c1367b486680bcf22987540e217cfb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a84c1367b486680bcf22987540e217cfb">stopAnimation</a> ()</td></tr>
<tr class="separator:a84c1367b486680bcf22987540e217cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64465ac69c7fe9f4f8519a57501c76c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate</a> ()</td></tr>
<tr class="separator:a64465ac69c7fe9f4f8519a57501c76c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67be4f5d4065852e7f46a2fc6197c070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a67be4f5d4065852e7f46a2fc6197c070">toggleAnimation</a> ()</td></tr>
<tr class="separator:a67be4f5d4065852e7f46a2fc6197c070"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Help window</h2></td></tr>
<tr class="memitem:a38ddb3cdf15e24de824a2d7a170ec915"><td class="memItemLeft" align="right" valign="top">virtual QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a38ddb3cdf15e24de824a2d7a170ec915">helpString</a> () const </td></tr>
<tr class="separator:a38ddb3cdf15e24de824a2d7a170ec915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d66b99a4c5a38ef0072f350b055201b"><td class="memItemLeft" align="right" valign="top">virtual QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a6d66b99a4c5a38ef0072f350b055201b">mouseString</a> () const </td></tr>
<tr class="separator:a6d66b99a4c5a38ef0072f350b055201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e20e13c1170d50b46b6fe2a49377690"><td class="memItemLeft" align="right" valign="top">virtual QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a0e20e13c1170d50b46b6fe2a49377690">keyboardString</a> () const </td></tr>
<tr class="separator:a0e20e13c1170d50b46b6fe2a49377690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ee70a8770dc30d06c744b24eb2fcfc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help</a> ()</td></tr>
<tr class="separator:a97ee70a8770dc30d06c744b24eb2fcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b8ca0f43910754ecd5d314e3febf0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#af08b8ca0f43910754ecd5d314e3febf0">aboutQGLViewer</a> ()</td></tr>
<tr class="separator:af08b8ca0f43910754ecd5d314e3febf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3af989be04f1d45b6ff3f748c2e9d4a"><td class="memItemLeft" align="right" valign="top">QTabWidget *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#af3af989be04f1d45b6ff3f748c2e9d4a">helpWidget</a> ()</td></tr>
<tr class="separator:af3af989be04f1d45b6ff3f748c2e9d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Drawing methods</h2></td></tr>
<tr class="memitem:a3efe88f982dbec7825725dd954991139"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3efe88f982dbec7825725dd954991139">resizeGL</a> (int <a class="el" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width</a>, int <a class="el" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height</a>)</td></tr>
<tr class="separator:a3efe88f982dbec7825725dd954991139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3d45239c78255c23a70ca558b4d4f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a2d3d45239c78255c23a70ca558b4d4f1">initializeGL</a> ()</td></tr>
<tr class="separator:a2d3d45239c78255c23a70ca558b4d4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9339772ec5ac9fa929938109207f2863"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">init</a> ()</td></tr>
<tr class="separator:a9339772ec5ac9fa929938109207f2863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cbfafb28ef4c0474ae96437294f547"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ac5cbfafb28ef4c0474ae96437294f547">paintGL</a> ()</td></tr>
<tr class="separator:ac5cbfafb28ef4c0474ae96437294f547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6b3ec107b4f010cf1fcd8c51ca92e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw</a> ()</td></tr>
<tr class="separator:a9c6b3ec107b4f010cf1fcd8c51ca92e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43df4754781c2aaf3236d676401cec59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a43df4754781c2aaf3236d676401cec59">preDrawStereo</a> (bool leftBuffer=true)</td></tr>
<tr class="separator:a43df4754781c2aaf3236d676401cec59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc45d04e5f5ce1fbd68f920fcdb2d0e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw</a> ()</td></tr>
<tr class="separator:abc45d04e5f5ce1fbd68f920fcdb2d0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6601997fe7a83e7cd041104d4b21d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a8b6601997fe7a83e7cd041104d4b21d2">fastDraw</a> ()</td></tr>
<tr class="separator:a8b6601997fe7a83e7cd041104d4b21d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f5dce22199f5eea71f034cae6ae4fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a24f5dce22199f5eea71f034cae6ae4fa">postDraw</a> ()</td></tr>
<tr class="separator:a24f5dce22199f5eea71f034cae6ae4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mouse, keyboard and event handlers</h2></td></tr>
<tr class="memitem:a991f0a076bd76a1ee5bda0df7fa474f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a991f0a076bd76a1ee5bda0df7fa474f4">mousePressEvent</a> (QMouseEvent *)</td></tr>
<tr class="separator:a991f0a076bd76a1ee5bda0df7fa474f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e672693c2cfdbaf9af942a58a8e1dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent</a> (QMouseEvent *)</td></tr>
<tr class="separator:a88e672693c2cfdbaf9af942a58a8e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158642bef03883cc4157b8b40e1aa0ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a158642bef03883cc4157b8b40e1aa0ea">mouseReleaseEvent</a> (QMouseEvent *)</td></tr>
<tr class="separator:a158642bef03883cc4157b8b40e1aa0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11ba8137b62942cede01c57aade3073"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aa11ba8137b62942cede01c57aade3073">mouseDoubleClickEvent</a> (QMouseEvent *)</td></tr>
<tr class="separator:aa11ba8137b62942cede01c57aade3073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc61c05ed30a94d66ab715c718532c03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#abc61c05ed30a94d66ab715c718532c03">wheelEvent</a> (QWheelEvent *)</td></tr>
<tr class="separator:abc61c05ed30a94d66ab715c718532c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc4c898ca007c7cc0ebb7791aa3e5b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a2cc4c898ca007c7cc0ebb7791aa3e5b3">keyPressEvent</a> (QKeyEvent *)</td></tr>
<tr class="separator:a2cc4c898ca007c7cc0ebb7791aa3e5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbb1d9848e9f0625bd0a7252e86de94"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3bbb1d9848e9f0625bd0a7252e86de94">keyReleaseEvent</a> (QKeyEvent *)</td></tr>
<tr class="separator:a3bbb1d9848e9f0625bd0a7252e86de94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd355cb527aec563bbefc75edc9deffd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#acd355cb527aec563bbefc75edc9deffd">timerEvent</a> (QTimerEvent *)</td></tr>
<tr class="separator:acd355cb527aec563bbefc75edc9deffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb8c90e5c48e6ccc09f9125aa86943e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3fb8c90e5c48e6ccc09f9125aa86943e">closeEvent</a> (QCloseEvent *)</td></tr>
<tr class="separator:a3fb8c90e5c48e6ccc09f9125aa86943e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Object selection</h2></td></tr>
<tr class="memitem:a0015a8bc683c3a1483c5ad638550bdde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a0015a8bc683c3a1483c5ad638550bdde">selectedName</a> () const </td></tr>
<tr class="separator:a0015a8bc683c3a1483c5ad638550bdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e131ca92b021fb8946a9af0b0c269d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a13e131ca92b021fb8946a9af0b0c269d">selectBufferSize</a> () const </td></tr>
<tr class="separator:a13e131ca92b021fb8946a9af0b0c269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ad2d80aa574d32ae8237f56cfd7e06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth</a> () const </td></tr>
<tr class="separator:a16ad2d80aa574d32ae8237f56cfd7e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0b15577ca9bcabc99c78601cfce59f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#adb0b15577ca9bcabc99c78601cfce59f">selectRegionHeight</a> () const </td></tr>
<tr class="separator:adb0b15577ca9bcabc99c78601cfce59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87015f560fd54b358d185482ae82eec3"><td class="memItemLeft" align="right" valign="top">GLuint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer</a> ()</td></tr>
<tr class="separator:a87015f560fd54b358d185482ae82eec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b20e4da96e6d8c038a08c7d34d182c6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select</a> (const QMouseEvent *event)</td></tr>
<tr class="separator:a3b20e4da96e6d8c038a08c7d34d182c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ed82c063635ce439d9c73223e20fd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#af2ed82c063635ce439d9c73223e20fd6">select</a> (const QPoint &amp;point)</td></tr>
<tr class="separator:af2ed82c063635ce439d9c73223e20fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af6dc4a89202211b764647caf3d1f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae8af6dc4a89202211b764647caf3d1f3">setSelectBufferSize</a> (int size)</td></tr>
<tr class="separator:ae8af6dc4a89202211b764647caf3d1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfc48a72feefc6c90bd187280853911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a0bfc48a72feefc6c90bd187280853911">setSelectRegionWidth</a> (int <a class="el" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width</a>)</td></tr>
<tr class="separator:a0bfc48a72feefc6c90bd187280853911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae830757057c41db506410fd3c332d7dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae830757057c41db506410fd3c332d7dd">setSelectRegionHeight</a> (int <a class="el" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height</a>)</td></tr>
<tr class="separator:ae830757057c41db506410fd3c332d7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa1327270d0bcdf991874e7d741afd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aeaa1327270d0bcdf991874e7d741afd5">setSelectedName</a> (int id)</td></tr>
<tr class="separator:aeaa1327270d0bcdf991874e7d741afd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a48cc50f194926bad38d4924162116"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#af0a48cc50f194926bad38d4924162116">beginSelection</a> (const QPoint &amp;point)</td></tr>
<tr class="separator:af0a48cc50f194926bad38d4924162116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528b238068a87472df8ac3a5b2481c55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames</a> ()</td></tr>
<tr class="separator:a528b238068a87472df8ac3a5b2481c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d164809a99bbe6ff2fc0dee33fe0e91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a0d164809a99bbe6ff2fc0dee33fe0e91">endSelection</a> (const QPoint &amp;point)</td></tr>
<tr class="separator:a0d164809a99bbe6ff2fc0dee33fe0e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc0d3b212e04bcafd63e9c3eb214a6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection</a> (const QPoint &amp;point)</td></tr>
<tr class="separator:a3dc0d3b212e04bcafd63e9c3eb214a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Keyboard customization</h2></td></tr>
<tr class="memitem:a7a90ec0b49f9586addb5eed9026077c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a> { <br />
&#160;&#160;<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1aa9c213a1cf39290bfcad5d6813d2395d">DRAW_AXIS</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a9891606ac8b160f15d3e705f7d192604">DRAW_GRID</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a7522d8401eb437769071ba3b1562ca97">DISPLAY_FPS</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1af12e793187e1edaf1e236818225b9e0e">ENABLE_TEXT</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a7ff2639b181c08e5d9196a0303a72cd1">EXIT_VIEWER</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a1e9b410aa72809cf30d86b2d34ee7239">SAVE_SCREENSHOT</a>, 
<br />
&#160;&#160;<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a91b759170cb0389695a3c219a9a69073">CAMERA_MODE</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a4750f7f8fc87e44b233c6186713f8e59">FULL_SCREEN</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1aa0cd9874b7ec35409aa4ef363b818a4e">STEREO</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1af3b49771c99e24d1407f9fc662fc7a6f">ANIMATION</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a9f5cb747b2e1f0ea781d2b1f2a5b4824">HELP</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a97ed373cfcaeadc41c6975357bbc17df">EDIT_CAMERA</a>, 
<br />
&#160;&#160;<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1ac71e3cca6e8031a8c05944d15f257b30">MOVE_CAMERA_LEFT</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1adee5dcac0e4f4dfe9190a769f3575a63">MOVE_CAMERA_RIGHT</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1aeaca3cc65bb13383b55ff6704f80adeb">MOVE_CAMERA_UP</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1ae8ffd7bbd8e032bf43298331a6525274">MOVE_CAMERA_DOWN</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a0f5233365123b2f88633907040a95a5a">INCREASE_FLYSPEED</a>, 
<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a595e91c7270892a31306f01e105c1dd8">DECREASE_FLYSPEED</a>, 
<br />
&#160;&#160;<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1af66c229e98a8724914c726433c735312">SNAPSHOT_TO_CLIPBOARD</a>
<br />
 }</td></tr>
<tr class="separator:a7a90ec0b49f9586addb5eed9026077c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f502daf9ffa61c8904f891c843e994"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#af8f502daf9ffa61c8904f891c843e994">shortcut</a> (<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a> action) const </td></tr>
<tr class="separator:af8f502daf9ffa61c8904f891c843e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5d27e632d4a2116e602bc67005b0e5"><td class="memItemLeft" align="right" valign="top">Qt::Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aab5d27e632d4a2116e602bc67005b0e5">pathKey</a> (unsigned int index) const </td></tr>
<tr class="separator:aab5d27e632d4a2116e602bc67005b0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad35c97454fee139eb809488ca7a8cb1"><td class="memItemLeft" align="right" valign="top">Qt::KeyboardModifiers&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aad35c97454fee139eb809488ca7a8cb1">addKeyFrameKeyboardModifiers</a> () const </td></tr>
<tr class="separator:aad35c97454fee139eb809488ca7a8cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cd07399d3ed7b88cdf69d9cd17488d"><td class="memItemLeft" align="right" valign="top">Qt::KeyboardModifiers&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a53cd07399d3ed7b88cdf69d9cd17488d">playPathKeyboardModifiers</a> () const </td></tr>
<tr class="separator:a53cd07399d3ed7b88cdf69d9cd17488d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d76d224c67a0fdae03f0d921bf3330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut</a> (<a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a> action, unsigned int key)</td></tr>
<tr class="separator:a34d76d224c67a0fdae03f0d921bf3330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33368bc379da582a3d26df18a6df16c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae33368bc379da582a3d26df18a6df16c">setKeyDescription</a> (unsigned int key, QString description)</td></tr>
<tr class="separator:ae33368bc379da582a3d26df18a6df16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02747804176d6db01421e12e699eb7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ac02747804176d6db01421e12e699eb7a">clearShortcuts</a> ()</td></tr>
<tr class="separator:ac02747804176d6db01421e12e699eb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5542c73a9c2c62be3cde9144d950fd13"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5542c73a9c2c62be3cde9144d950fd13">setPathKey</a> (int key, unsigned int index=0)</td></tr>
<tr class="separator:a5542c73a9c2c62be3cde9144d950fd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e16934baadfe8db4f68dedc98075a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ab8e16934baadfe8db4f68dedc98075a1">setPlayPathKeyboardModifiers</a> (Qt::KeyboardModifiers modifiers)</td></tr>
<tr class="separator:ab8e16934baadfe8db4f68dedc98075a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe04d1c918e50f6b4db5f7b6c7b80219"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#afe04d1c918e50f6b4db5f7b6c7b80219">setAddKeyFrameKeyboardModifiers</a> (Qt::KeyboardModifiers modifiers)</td></tr>
<tr class="separator:afe04d1c918e50f6b4db5f7b6c7b80219"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mouse customization</h2></td></tr>
<tr class="memitem:a5b90ab220b7700ca28db5ecf3217325d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> { <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325dada31f516cdf218b68b790fb31e8a6956">CAMERA</a>, 
<a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325da200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>
 }</td></tr>
<tr class="separator:a5b90ab220b7700ca28db5ecf3217325d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fe75121d351785616b75b2c5661d8f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a> { <br />
&#160;&#160;<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8faed60c81bb5edd0570ff12ac8a0e2b604">NO_CLICK_ACTION</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fac7b18b21c4c8f1eeb5d54bf1b7919db4">ZOOM_ON_PIXEL</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fab1efbb77356f16254fd4a62e1236b531">ZOOM_TO_FIT</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa1697a91b22c2369eb2ba427c2d193329">SELECT</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa6423101303db857a4217e8e66606128a">RAP_FROM_PIXEL</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa131d4a2b38607d5d753c4fe19884a9cc">RAP_IS_CENTER</a>, 
<br />
&#160;&#160;<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fabf4ad7098f468bfaf170fd5e16902929">CENTER_FRAME</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa23a1d829d84b71f5aa5a0e19385e8ce7">CENTER_SCENE</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa3f717d1605f3ca83254beb93ea399ddc">SHOW_ENTIRE_SCENE</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa3d318f59bc81979e3922c7e716085304">ALIGN_FRAME</a>, 
<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa35685e5c7e681c3c0eb079e4f132a82a">ALIGN_CAMERA</a>
<br />
 }</td></tr>
<tr class="separator:a85fe75121d351785616b75b2c5661d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded669cb17515ea2b5971496f9aef875"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a> { <br />
&#160;&#160;<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3b20d5f27f63af5ea6e5b6af1112ecf8">NO_MOUSE_ACTION</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3dcfe0046eb5876e287dbf0914819b16">ROTATE</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a604adefe799fe794cab6b76ed1108201">ZOOM</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875abc6501410409b0638909b580970b35f7">TRANSLATE</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a99906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a21fa52d8ef1574dce79cab9ddbb6cd73">LOOK_AROUND</a>, 
<br />
&#160;&#160;<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875ab3313fc5887b62fd14b36f1d67903e08">MOVE_BACKWARD</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a410b0fa7f49e7eedd6d739db37c67209">SCREEN_ROTATE</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a2eeb9fef8a6a516fa6437a44a6efbd52">ROLL</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875af7b6d6d8e5e14633d388ef9cc7a941b7">DRIVE</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3de224b064ad81a76d8739cf288543a3">SCREEN_TRANSLATE</a>, 
<a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875afbac98d470c69690e178ff5ab9ad504d">ZOOM_ON_REGION</a>
<br />
 }</td></tr>
<tr class="separator:aded669cb17515ea2b5971496f9aef875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab689056381e744de41ccc27383294692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ab689056381e744de41ccc27383294692">mouseAction</a> (Qt::Key key, Qt::KeyboardModifiers modifiers, Qt::MouseButton button) const </td></tr>
<tr class="separator:ab689056381e744de41ccc27383294692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692798e25eba7676d441fabd153dc77c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a692798e25eba7676d441fabd153dc77c">mouseHandler</a> (Qt::Key key, Qt::KeyboardModifiers modifiers, Qt::MouseButton button) const </td></tr>
<tr class="separator:a692798e25eba7676d441fabd153dc77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcad615739f9ce3e857b94ca945deb5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#abcad615739f9ce3e857b94ca945deb5e">getMouseActionBinding</a> (<a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint, Qt::Key &amp;key, Qt::KeyboardModifiers &amp;modifiers, Qt::MouseButton &amp;button) const </td></tr>
<tr class="separator:abcad615739f9ce3e857b94ca945deb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe4c9b3104cd089f855a1761c9f9ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aebe4c9b3104cd089f855a1761c9f9ad8">clickAction</a> (Qt::Key key, Qt::KeyboardModifiers modifiers, Qt::MouseButton button, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton) const </td></tr>
<tr class="separator:aebe4c9b3104cd089f855a1761c9f9ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57d9efa984795d6cfbe85ad594f660f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae57d9efa984795d6cfbe85ad594f660f">getClickActionBinding</a> (<a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a> action, Qt::Key &amp;key, Qt::KeyboardModifiers &amp;modifiers, Qt::MouseButton &amp;button, bool &amp;doubleClick, Qt::MouseButtons &amp;buttonsBefore) const </td></tr>
<tr class="separator:ae57d9efa984795d6cfbe85ad594f660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3605551bb140ab0c38c78c55722621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a8d3605551bb140ab0c38c78c55722621">wheelAction</a> (Qt::Key key, Qt::KeyboardModifiers modifiers) const </td></tr>
<tr class="separator:a8d3605551bb140ab0c38c78c55722621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783e829b316bac1cb3c7baaff46797e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a783e829b316bac1cb3c7baaff46797e7">wheelHandler</a> (Qt::Key key, Qt::KeyboardModifiers modifiers) const </td></tr>
<tr class="separator:a783e829b316bac1cb3c7baaff46797e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5b32b9880a9f32d590871663713b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a0f5b32b9880a9f32d590871663713b78">getWheelActionBinding</a> (<a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint, Qt::Key &amp;key, Qt::KeyboardModifiers &amp;modifiers) const </td></tr>
<tr class="separator:a0f5b32b9880a9f32d590871663713b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e3c0b956c3fea7dc804e7a7a7dd295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding</a> (Qt::KeyboardModifiers modifiers, Qt::MouseButton buttons, <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint=true)</td></tr>
<tr class="separator:a98e3c0b956c3fea7dc804e7a7a7dd295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60ec98df1af2309ef1d16644e9791ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#af60ec98df1af2309ef1d16644e9791ef">setMouseBinding</a> (Qt::KeyboardModifiers modifiers, Qt::MouseButton button, <a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a> action, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton)</td></tr>
<tr class="separator:af60ec98df1af2309ef1d16644e9791ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277f432be05de69ae2df05eac8951ad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding</a> (Qt::KeyboardModifiers modifiers, <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint=true)</td></tr>
<tr class="separator:a277f432be05de69ae2df05eac8951ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6952d2191d9e47e295fb53248d47702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ae6952d2191d9e47e295fb53248d47702">setMouseBindingDescription</a> (Qt::KeyboardModifiers modifiers, Qt::MouseButton button, QString description, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton)</td></tr>
<tr class="separator:ae6952d2191d9e47e295fb53248d47702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a2e51796cd902ecc2bdc9ae143e4d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a85a2e51796cd902ecc2bdc9ae143e4d5">setMouseBinding</a> (Qt::Key key, Qt::KeyboardModifiers modifiers, Qt::MouseButton buttons, <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint=true)</td></tr>
<tr class="separator:a85a2e51796cd902ecc2bdc9ae143e4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837a7cd6b3fa87bff0f1ae85f79fc7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a837a7cd6b3fa87bff0f1ae85f79fc7ce">setMouseBinding</a> (Qt::Key key, Qt::KeyboardModifiers modifiers, Qt::MouseButton button, <a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a> action, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton)</td></tr>
<tr class="separator:a837a7cd6b3fa87bff0f1ae85f79fc7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac418dcff525e4236ebd4e8324fb725b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#ac418dcff525e4236ebd4e8324fb725b1">setWheelBinding</a> (Qt::Key key, Qt::KeyboardModifiers modifiers, <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a> handler, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a> action, bool withConstraint=true)</td></tr>
<tr class="separator:ac418dcff525e4236ebd4e8324fb725b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abc54d8039991ecc1f880fa0c0c4d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a5abc54d8039991ecc1f880fa0c0c4d2d">setMouseBindingDescription</a> (Qt::Key key, Qt::KeyboardModifiers modifiers, Qt::MouseButton button, QString description, bool doubleClick=false, Qt::MouseButtons buttonsBefore=Qt::NoButton)</td></tr>
<tr class="separator:a5abc54d8039991ecc1f880fa0c0c4d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70012fbf36d43b3f618bd339c123d8b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a70012fbf36d43b3f618bd339c123d8b7">clearMouseBindings</a> ()</td></tr>
<tr class="separator:a70012fbf36d43b3f618bd339c123d8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
State persistence</h2></td></tr>
<tr class="memitem:a62b572fd9b9afecb2ac055a24ca9dfa0"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName</a> () const </td></tr>
<tr class="separator:a62b572fd9b9afecb2ac055a24ca9dfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e0e2dd26cd96418c8b889ceabe80f6"><td class="memItemLeft" align="right" valign="top">virtual QDomElement&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement</a> (const QString &amp;name, QDomDocument &amp;document) const </td></tr>
<tr class="separator:a48e0e2dd26cd96418c8b889ceabe80f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd13d2ddeca530cb9f26ead47f7d25d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#acd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement</a> (const QDomElement &amp;element)</td></tr>
<tr class="separator:acd13d2ddeca530cb9f26ead47f7d25d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec9168a5f41b3b7fa4211523535ceaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#aaec9168a5f41b3b7fa4211523535ceaa">saveStateToFile</a> ()</td></tr>
<tr class="separator:aaec9168a5f41b3b7fa4211523535ceaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212f6b7b669463c2151688f629d72a81"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile</a> ()</td></tr>
<tr class="separator:a212f6b7b669463c2151688f629d72a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68737cce3d7301701bca6e4270a5a34e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a68737cce3d7301701bca6e4270a5a34e">setStateFileName</a> (const QString &amp;name)</td></tr>
<tr class="separator:a68737cce3d7301701bca6e4270a5a34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
QGLViewer pool</h2></td></tr>
<tr class="memitem:a32d7a506084c50fd97a24f94d9ca4864"><td class="memItemLeft" align="right" valign="top">static const QList&lt; QGLViewer * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a32d7a506084c50fd97a24f94d9ca4864">QGLViewerPool</a> ()</td></tr>
<tr class="separator:a32d7a506084c50fd97a24f94d9ca4864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9570ddcbaab08bce6f121e69db4fb903"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGLViewer.html#a9570ddcbaab08bce6f121e69db4fb903">QGLViewerIndex</a> (const QGLViewer *const viewer)</td></tr>
<tr class="separator:a9570ddcbaab08bce6f121e69db4fb903"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A versatile 3D OpenGL viewer based on QGLWidget. </p>
<p>It features many classical viewer functionalities, such as a camera trackball, manipulated objects, snapshot saving and much <a href="../features.html">more</a>. Its main goal is to ease the development of new 3D applications.</p>
<p>New users should read the <a href="../introduction.html">introduction page</a> to get familiar with important notions such as <a class="el" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius()</a>, <a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a> and the world coordinate system. Try the numerous simple <a href="../examples/index.html">examples</a> to discover the possibilities and understand how it works.</p>
<h3>Usage</h3>
<p>To use a QGLViewer, derive you viewer class from the QGLViewer and overload its <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> virtual method. See the <a href="../examples/simpleViewer.html">simpleViewer example</a> for an illustration.</p>
<p>An other option is to connect your drawing methods to the signals emitted by the QGLViewer (Qt's callback mechanism). See the <a href="../examples/callback.html">callback example</a> for a complete implementation. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a85fe75121d351785616b75b2c5661d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the possible actions that can be binded to a mouse click using setMouseBinding(Qt::KeyboardModifiers, Qt::MouseButtons, ClickAction, bool, int).</p>
<p>See the <a href="../mouse.html">mouse page</a> for details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8faed60c81bb5edd0570ff12ac8a0e2b604"></a>NO_CLICK_ACTION&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fac7b18b21c4c8f1eeb5d54bf1b7919db4"></a>ZOOM_ON_PIXEL&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fab1efbb77356f16254fd4a62e1236b531"></a>ZOOM_TO_FIT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fa1697a91b22c2369eb2ba427c2d193329"></a>SELECT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fa6423101303db857a4217e8e66606128a"></a>RAP_FROM_PIXEL&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fa131d4a2b38607d5d753c4fe19884a9cc"></a>RAP_IS_CENTER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fabf4ad7098f468bfaf170fd5e16902929"></a>CENTER_FRAME&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fa23a1d829d84b71f5aa5a0e19385e8ce7"></a>CENTER_SCENE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fa3f717d1605f3ca83254beb93ea399ddc"></a>SHOW_ENTIRE_SCENE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fa3d318f59bc81979e3922c7e716085304"></a>ALIGN_FRAME&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a85fe75121d351785616b75b2c5661d8fa35685e5c7e681c3c0eb079e4f132a82a"></a>ALIGN_CAMERA&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the different actions that can be associated with a keyboard shortcut using <a class="el" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut()</a>.</p>
<p>See the <a href="../keyboard.html">keyboard page</a> for details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1aa9c213a1cf39290bfcad5d6813d2395d"></a>DRAW_AXIS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a9891606ac8b160f15d3e705f7d192604"></a>DRAW_GRID&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a7522d8401eb437769071ba3b1562ca97"></a>DISPLAY_FPS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1af12e793187e1edaf1e236818225b9e0e"></a>ENABLE_TEXT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a7ff2639b181c08e5d9196a0303a72cd1"></a>EXIT_VIEWER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a1e9b410aa72809cf30d86b2d34ee7239"></a>SAVE_SCREENSHOT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a91b759170cb0389695a3c219a9a69073"></a>CAMERA_MODE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a4750f7f8fc87e44b233c6186713f8e59"></a>FULL_SCREEN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1aa0cd9874b7ec35409aa4ef363b818a4e"></a>STEREO&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1af3b49771c99e24d1407f9fc662fc7a6f"></a>ANIMATION&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a9f5cb747b2e1f0ea781d2b1f2a5b4824"></a>HELP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a97ed373cfcaeadc41c6975357bbc17df"></a>EDIT_CAMERA&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1ac71e3cca6e8031a8c05944d15f257b30"></a>MOVE_CAMERA_LEFT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1adee5dcac0e4f4dfe9190a769f3575a63"></a>MOVE_CAMERA_RIGHT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1aeaca3cc65bb13383b55ff6704f80adeb"></a>MOVE_CAMERA_UP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1ae8ffd7bbd8e032bf43298331a6525274"></a>MOVE_CAMERA_DOWN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a0f5233365123b2f88633907040a95a5a"></a>INCREASE_FLYSPEED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1a595e91c7270892a31306f01e105c1dd8"></a>DECREASE_FLYSPEED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a90ec0b49f9586addb5eed9026077c1af66c229e98a8724914c726433c735312"></a>SNAPSHOT_TO_CLIPBOARD&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aded669cb17515ea2b5971496f9aef875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the possible actions that can be binded to a mouse action (a click, followed by a mouse displacement).</p>
<p>These actions may be binded to the <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> or to the <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> (see <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">QGLViewer::MouseHandler</a>) using <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875a3b20d5f27f63af5ea6e5b6af1112ecf8"></a>NO_MOUSE_ACTION&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875a3dcfe0046eb5876e287dbf0914819b16"></a>ROTATE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875a604adefe799fe794cab6b76ed1108201"></a>ZOOM&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875abc6501410409b0638909b580970b35f7"></a>TRANSLATE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875a99906f0ddded6cfdab57271cd33e308c"></a>MOVE_FORWARD&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875a21fa52d8ef1574dce79cab9ddbb6cd73"></a>LOOK_AROUND&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875ab3313fc5887b62fd14b36f1d67903e08"></a>MOVE_BACKWARD&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875a410b0fa7f49e7eedd6d739db37c67209"></a>SCREEN_ROTATE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875a2eeb9fef8a6a516fa6437a44a6efbd52"></a>ROLL&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875af7b6d6d8e5e14633d388ef9cc7a941b7"></a>DRIVE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875a3de224b064ad81a76d8739cf288543a3"></a>SCREEN_TRANSLATE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aded669cb17515ea2b5971496f9aef875afbac98d470c69690e178ff5ab9ad504d"></a>ZOOM_ON_REGION&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a5b90ab220b7700ca28db5ecf3217325d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the different mouse handlers: <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> or <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>.</p>
<p>Used by <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a>, setMouseBinding(Qt::KeyboardModifiers modifiers, Qt::MouseButtons, ClickAction, bool, int) and <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a> to define which handler receives the mouse events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a5b90ab220b7700ca28db5ecf3217325dada31f516cdf218b68b790fb31e8a6956"></a>CAMERA&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5b90ab220b7700ca28db5ecf3217325da200c1bcf1eaa8635daa3cbb5fdd2ebb6"></a>FRAME&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5cfffe102b268c9af761c5d82a694dcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QGLViewer </td>
          <td>(</td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QGLWidget *&#160;</td>
          <td class="paramname"><em>shareWidget</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::WindowFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. See <code>QGLWidget</code> documentation for details.</p>
<p>All viewer parameters (display flags, scene parameters, associated objects...) are set to their default values. See the associated documentation.</p>
<p>If the <code>shareWidget</code> parameter points to a valid <code>QGLWidget</code>, the QGLViewer will share the OpenGL context with <code>shareWidget</code> (see <a class="el" href="classQGLViewer.html#a514d24ec3ec6c94657ef302a2b3fa74a">isSharing()</a>). </p>

</div>
</div>
<a class="anchor" id="a4724b62429d2ecd9049bc41a562901b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QGLViewer </td>
          <td>(</td>
          <td class="paramtype">QGLContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QGLWidget *&#160;</td>
          <td class="paramname"><em>shareWidget</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::WindowFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classQGLViewer.html#a5cfffe102b268c9af761c5d82a694dcc">QGLViewer()</a>, but a <code>QGLContext</code> can be provided so that viewers share GL contexts, even with <code>QGLContext</code> sub-classes (use <code>shareWidget</code> otherwise). </p>

</div>
</div>
<a class="anchor" id="a5b655fa44abb36439e4f7ef3ad2cd649"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QGLViewer </td>
          <td>(</td>
          <td class="paramtype">const QGLFormat &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QGLWidget *&#160;</td>
          <td class="paramname"><em>shareWidget</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::WindowFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classQGLViewer.html#a5cfffe102b268c9af761c5d82a694dcc">QGLViewer()</a>, but a specific <code>QGLFormat</code> can be provided.</p>
<p>This is for instance needed to ask for a stencil buffer or for stereo display (as is illustrated in the <a href="../examples/stereoViewer.html">stereoViewer example</a>). </p>

</div>
</div>
<a class="anchor" id="a8c90239e64b7a43473a189d5da865ac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~QGLViewer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual destructor.</p>
<p>The viewer is replaced by <code>NULL</code> in the <a class="el" href="classQGLViewer.html#a32d7a506084c50fd97a24f94d9ca4864">QGLViewerPool()</a> (in order to preserve other viewer's indexes) and allocated memory is released. The <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> is deleted and should be copied before if it is shared by an other viewer. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af08b8ca0f43910754ecd5d314e3febf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aboutQGLViewer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Displays the help window "About" tab. See <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> for details. </p>

</div>
</div>
<a class="anchor" id="aad35c97454fee139eb809488ca7a8cb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Qt::KeyboardModifiers addKeyFrameKeyboardModifiers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the keyboard modifiers that must be pressed with a <a class="el" href="classQGLViewer.html#aab5d27e632d4a2116e602bc67005b0e5">pathKey()</a> to add the current camera position to a KeyFrame path.</p>
<p>It can be <code>Qt::NoModifier</code>, <code>Qt::ControlModifier</code>, <code>Qt::ShiftModifier</code>, <code>Qt::AltModifier</code>, <code>Qt::MetaModifier</code> or a combination of these (using the bitwise '|' operator).</p>
<p>Default value is Qt::AltModifier. Defined using <a class="el" href="classQGLViewer.html#afe04d1c918e50f6b4db5f7b6c7b80219">setAddKeyFrameKeyboardModifiers()</a>.</p>
<p>See also <a class="el" href="classQGLViewer.html#a53cd07399d3ed7b88cdf69d9cd17488d">playPathKeyboardModifiers()</a>. </p>

</div>
</div>
<a class="anchor" id="a64465ac69c7fe9f4f8519a57501c76c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void animate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scene animation method. </p><pre class="fragment">When animationIsStarted(), this method is in charge of the scene update before each draw().
Overload it to define how your scene evolves over time. The time should either be regularly
incremented in this method (frame-rate independent animation) or computed from actual time (for
instance using QTime::elapsed()) for real-time animations.

            Note that KeyFrameInterpolator (which regularly updates a Frame) does not use this method
            to animate a Frame, but rather rely on a QTimer signal-slot mechanism.

See the &lt;a href="../examples/animation.html"&gt;animation example&lt;/a&gt; for an illustration.  </pre> 
</div>
</div>
<a class="anchor" id="a841503c97db5a51e33f8a7e56d4ca006"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void animateNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal emitted by the default <a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate()</a> method.</p>
<p>Connect this signal to your scene animation method or overload <a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate()</a>. </p>

</div>
</div>
<a class="anchor" id="ad865668850fb0aa249e79f21d2e9d40e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool animationIsStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>true</code> when the animation loop is started.</p>
<p>During animation, an infinite loop calls <a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> and then waits for <a class="el" href="classQGLViewer.html#a700d9398d4293d9274766efa8b17917e">animationPeriod()</a> milliseconds before calling <a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> again. And again.</p>
<p>Use <a class="el" href="classQGLViewer.html#ad5344a5f702678f309fafa0c699b2cf3">startAnimation()</a>, <a class="el" href="classQGLViewer.html#a84c1367b486680bcf22987540e217cfb">stopAnimation()</a> or <a class="el" href="classQGLViewer.html#a67be4f5d4065852e7f46a2fc6197c070">toggleAnimation()</a> to change this value.</p>
<p>See the <a href="../examples/animation.html">animation example</a> for illustration. </p>

</div>
</div>
<a class="anchor" id="a700d9398d4293d9274766efa8b17917e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int animationPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The animation loop period, in milliseconds.</p>
<p>When <a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>, this is delay waited after <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> to call <a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> again. Default value is 40 milliseconds (25 Hz).</p>
<p>This value will define the <a class="el" href="classQGLViewer.html#a6d52227793dba3e2f87f07acec26fd56">currentFPS()</a> when <a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a> (provided that your <a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> methods are fast enough).</p>
<p>If you want to know the maximum possible frame rate of your machine on a given scene, <a class="el" href="classQGLViewer.html#aa37d4e0afe6a47e8f4f828ed41072176">setAnimationPeriod()</a> to <code>0</code>, and <a class="el" href="classQGLViewer.html#ad5344a5f702678f309fafa0c699b2cf3">startAnimation()</a> (keyboard shortcut is <code>Enter</code>). The display will then be updated as often as possible, and the frame rate will be meaningful.</p>
<dl class="section note"><dt>Note</dt><dd>This value is taken into account only the next time you call <a class="el" href="classQGLViewer.html#ad5344a5f702678f309fafa0c699b2cf3">startAnimation()</a>. If <a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>, you should <a class="el" href="classQGLViewer.html#a84c1367b486680bcf22987540e217cfb">stopAnimation()</a> first. </dd></dl>

</div>
</div>
<a class="anchor" id="a06471e2ca19ce8da106ee4b996687b01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qreal aspectRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the aspect ratio of the viewer's widget (<a class="el" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width()</a> / <a class="el" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height()</a>). </p>

</div>
</div>
<a class="anchor" id="a36faca915c37548a53ab04f297bb5c17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool autoBufferSwap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> when buffers are automatically swapped (default). See details in the QGLWidget documentation. </p>

</div>
</div>
<a class="anchor" id="a7d38e6f11078e886f7978525def15797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool axisIsDrawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the world axis is drawn by the viewer.</p>
<p>Set by <a class="el" href="classQGLViewer.html#a5be8cff3702c1a130f8a17330737a887">setAxisIsDrawn()</a> or <a class="el" href="classQGLViewer.html#acf2ccb8a346c04a5c7da87da0e8e601f">toggleAxisIsDrawn()</a>. Default value is <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a541cdbec67d0c5895cd6c77c01b0f89e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axisIsDrawnChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drawn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever <a class="el" href="classQGLViewer.html#a7d38e6f11078e886f7978525def15797">axisIsDrawn()</a> changes value. </p>

</div>
</div>
<a class="anchor" id="a7ddf68dcfb09cc5a991a06d91cb4cc5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QColor backgroundColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the background color of the viewer.</p>
<p>This method is provided for convenience since the background color is an OpenGL state variable set with <code>glClearColor()</code>. However, this internal representation has the advantage that it is saved (resp. restored) with <a class="el" href="classQGLViewer.html#aaec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a> (resp. <a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a>).</p>
<p>Use <a class="el" href="classQGLViewer.html#a70d4e21190fdc47edd88f078dd2037cb">setBackgroundColor()</a> to define and activate a background color.</p>
<dl class="section attention"><dt>Attention</dt><dd>Each QColor component is an integer ranging from 0 to 255. This differs from the qreal values used by <code>glClearColor()</code> which are in the 0.0-1.0 range. Default value is (51, 51, 51) (dark gray). You may have to change <a class="el" href="classQGLViewer.html#aa2f726def3615050a9c816c0ca32171d">foregroundColor()</a> accordingly.</dd>
<dd>
This method does not return the current OpenGL clear color as <code>glGet()</code> does. Instead, it returns the QGLViewer internal variable. If you directly use <code>glClearColor()</code> or <code><a class="el" href="classQGLViewer.html#a88b363f05e720484cde551d5f798e69b">qglClearColor()</a></code> instead of <a class="el" href="classQGLViewer.html#a70d4e21190fdc47edd88f078dd2037cb">setBackgroundColor()</a>, the two results will differ. </dd></dl>

</div>
</div>
<a class="anchor" id="af0a48cc50f194926bad38d4924162116"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void beginSelection </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should prepare the selection. It is called by <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> before <a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>.</p>
<p>The default implementation uses the <code>GL_SELECT</code> mode to perform a selection. It uses <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a> and <a class="el" href="classQGLViewer.html#a13e131ca92b021fb8946a9af0b0c269d">selectBufferSize()</a> to define a <code>glSelectBuffer()</code>. The <code>GL_PROJECTION</code> is then set using <code>gluPickMatrix()</code>, with a window selection size defined by <a class="el" href="classQGLViewer.html#a16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth()</a> and <a class="el" href="classQGLViewer.html#adb0b15577ca9bcabc99c78601cfce59f">selectRegionHeight()</a>. Finally, the <code>GL_MODELVIEW</code> matrix is set to the world coordinate system using <a class="el" href="classqglviewer_1_1Camera.html#a81053f822008b76bff7b1a41dceedf53">qglviewer::Camera::loadModelViewMatrix()</a>. See the gluPickMatrix() documentation for details.</p>
<p>You should not need to redefine this method (if you use the <code>GL_SELECT</code> mode to perform your selection), since this code is fairly classical and can be tuned. You are more likely to overload <a class="el" href="classQGLViewer.html#a0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> if you want to use a more complex select buffer structure. </p>

</div>
</div>
<a class="anchor" id="a6435e0a64e14d04dce25e524051f8d69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint bufferTextureId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the texture id of the texture created by <a class="el" href="classQGLViewer.html#aeb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture()</a>.</p>
<p>Use glBindTexture() to use this texture. Note that this is already done by <a class="el" href="classQGLViewer.html#aeb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture()</a>.</p>
<p>Returns <code>0</code> is <a class="el" href="classQGLViewer.html#aeb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture()</a> was never called or if the texure was deleted using glDeleteTextures() since then. </p>

</div>
</div>
<a class="anchor" id="aa7d083b81d5799f5a7ec768117b9f4a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qreal bufferTextureMaxU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the texture coordinate corresponding to the u extremum of the bufferTexture.</p>
<p>The bufferTexture is created by <a class="el" href="classQGLViewer.html#aeb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture()</a>. The texture size has powers of two dimensions and the buffer image hence only fills a part of it. This value corresponds to the u coordinate of the extremum right side of the buffer image.</p>
<p>Use (0,0) to (<a class="el" href="classQGLViewer.html#aa7d083b81d5799f5a7ec768117b9f4a2">bufferTextureMaxU()</a>, <a class="el" href="classQGLViewer.html#accce92c989155aebccfb5dc05c2b8bf9">bufferTextureMaxV()</a>) texture coordinates to map the entire texture on a quad. </p>

</div>
</div>
<a class="anchor" id="accce92c989155aebccfb5dc05c2b8bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qreal bufferTextureMaxV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classQGLViewer.html#aa7d083b81d5799f5a7ec768117b9f4a2">bufferTextureMaxU()</a>, but for the v texture coordinate. </p>

</div>
</div>
<a class="anchor" id="a27a9e97573822d296b48e1c408b74042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a>* camera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the associated <a class="el" href="classqglviewer_1_1Camera.html" title="A perspective or orthographic camera. ">qglviewer::Camera</a>, never <code>NULL</code>. </p>

</div>
</div>
<a class="anchor" id="a1bf2817fb27f0ad326e3db75aeb46af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cameraIsEdited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> is being edited in the viewer.</p>
<p>Set by <a class="el" href="classQGLViewer.html#a521c83b1d745b37331932b4d7b976d41">setCameraIsEdited()</a> or <a class="el" href="classQGLViewer.html#a3a53b30eacfccf0825b808977d634936">toggleCameraIsEdited()</a>. Default value is <code>false</code>.</p>
<p>The current implementation is limited: the defined <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> paths (see <a class="el" href="classqglviewer_1_1Camera.html#ad4acc41f907360dc96eaa219728948b7">qglviewer::Camera::keyFrameInterpolator()</a>) are simply displayed using <a class="el" href="classqglviewer_1_1Camera.html#aeea4caff561e6b1d8fe4b3d8efe4ae87">qglviewer::Camera::drawAllPaths()</a>. Actual camera and path edition will be implemented in the future. </p>

</div>
</div>
<a class="anchor" id="a38968d2f050efa14869c2e4de416b7b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cameraIsEditedChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>edited</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever <a class="el" href="classQGLViewer.html#a1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited()</a> changes value.. </p>

</div>
</div>
<a class="anchor" id="a70012fbf36d43b3f618bd339c123d8b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearMouseBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears all the default mouse bindings.</p>
<p>After this call, you will have to use <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a> to restore the mouse bindings you are interested in. </p>

</div>
</div>
<a class="anchor" id="ac02747804176d6db01421e12e699eb7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearShortcuts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears all the default keyboard shortcuts.</p>
<p>After this call, you will have to use <a class="el" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut()</a> to define your own keyboard shortcuts. </p>

</div>
</div>
<a class="anchor" id="aebe4c9b3104cd089f855a1761c9f9ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">QGLViewer::ClickAction</a> clickAction </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleClick</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons&#160;</td>
          <td class="paramname"><em>buttonsBefore</em> = <code>Qt::NoButton</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classQGLViewer.html#ab689056381e744de41ccc27383294692">mouseAction()</a>, but for the ClickAction set using <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a>.</p>
<p>Returns NO_CLICK_ACTION if no click action is associated with this keyboard and mouse buttons combination. </p>

</div>
</div>
<a class="anchor" id="a3fb8c90e5c48e6ccc09f9125aa86943e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void closeEvent </td>
          <td>(</td>
          <td class="paramtype">QCloseEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloading of the <code>QWidget</code> method.</p>
<p>Saves the viewer state using <a class="el" href="classQGLViewer.html#aaec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a> and then calls QGLWidget::closeEvent(). </p>

</div>
</div>
<a class="anchor" id="a75679575b3b071cddce2a56c77e1bd68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static QImage convertToGLFormat </td>
          <td>(</td>
          <td class="paramtype">const QImage &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts <code>image</code> into the unnamed format expected by OpenGL methods such as glTexImage2D(). See QGLWidget documentation. </p>

</div>
</div>
<a class="anchor" id="aeb1721bfb1c032ae68665808bb2f4453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copyBufferToTexture </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>internalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>format</em> = <code>GL_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes a copy of the current buffer into a texture.</p>
<p>Creates a texture (when needed) and uses glCopyTexSubImage2D() to directly copy the buffer in it.</p>
<p>Use <code>internalFormat</code> and <code>format</code> to define the texture format and hence which and how components of the buffer are copied into the texture. See the glTexImage2D() documentation for details.</p>
<p>When <code>format</code> is c GL_NONE (default), its value is set to <code>internalFormat</code>, which fits most cases. Typical <code>internalFormat</code> (and <code>format</code>) values are <code>GL_DEPTH_COMPONENT</code> and <code>GL_RGBA</code>. Use <code>GL_LUMINANCE</code> as the <code>internalFormat</code> and <code>GL_RED</code>, <code>GL_GREEN</code> or <code>GL_BLUE</code> as <code>format</code> to capture a single color component as a luminance (grey scaled) value. Note that <code>GL_STENCIL</code> is not supported as a format.</p>
<p>The texture has dimensions which are powers of two. It is as small as possible while always being larger or equal to the current size of the widget. The buffer image hence does not entirely fill the texture: it is stuck to the lower left corner (corresponding to the (0,0) texture coordinates). Use <a class="el" href="classQGLViewer.html#aa7d083b81d5799f5a7ec768117b9f4a2">bufferTextureMaxU()</a> and <a class="el" href="classQGLViewer.html#accce92c989155aebccfb5dc05c2b8bf9">bufferTextureMaxV()</a> to get the upper right corner maximum u and v texture coordinates. Use <a class="el" href="classQGLViewer.html#a6435e0a64e14d04dce25e524051f8d69">bufferTextureId()</a> to retrieve the id of the created texture.</p>
<p>Here is how to display a grey-level image of the z-buffer: </p><div class="fragment"><div class="line"><a class="code" href="classQGLViewer.html#aeb1721bfb1c032ae68665808bb2f4453">copyBufferToTexture</a>(GL_DEPTH_COMPONENT);</div>
<div class="line"></div>
<div class="line">glMatrixMode(GL_TEXTURE);</div>
<div class="line">glLoadIdentity();</div>
<div class="line"></div>
<div class="line">glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);</div>
<div class="line">glEnable(GL_TEXTURE_2D);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classQGLViewer.html#a5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem</a>(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">glBegin(GL_QUADS);</div>
<div class="line">glTexCoord2f(0.0, 0.0);                                 glVertex2i(0, 0);</div>
<div class="line">glTexCoord2f(<a class="code" href="classQGLViewer.html#aa7d083b81d5799f5a7ec768117b9f4a2">bufferTextureMaxU</a>(), 0.0);                 glVertex2i(<a class="code" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width</a>(), 0);</div>
<div class="line">glTexCoord2f(<a class="code" href="classQGLViewer.html#aa7d083b81d5799f5a7ec768117b9f4a2">bufferTextureMaxU</a>(), <a class="code" href="classQGLViewer.html#accce92c989155aebccfb5dc05c2b8bf9">bufferTextureMaxV</a>()); glVertex2i(<a class="code" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width</a>(), <a class="code" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height</a>());</div>
<div class="line">glTexCoord2f(0.0, <a class="code" href="classQGLViewer.html#accce92c989155aebccfb5dc05c2b8bf9">bufferTextureMaxV</a>());                 glVertex2i(0, <a class="code" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height</a>());</div>
<div class="line">glEnd();</div>
<div class="line"></div>
<div class="line"><a class="code" href="classQGLViewer.html#a9cff22af974391604bff7f91df789138">stopScreenCoordinatesSystem</a>();</div>
<div class="line"></div>
<div class="line">glDisable(GL_TEXTURE_2D);</div>
</div><!-- fragment --><p>Use glReadBuffer() to select which buffer is copied into the texture. See also <code>glPixelTransfer()</code>, <code>glPixelZoom()</code> and <code>glCopyPixel()</code> for pixel color transformations during copy.</p>
<p>Call <a class="el" href="classQGLViewer.html#a1436277e13026c94601bbe37a2f1d262">makeCurrent()</a> before this method to make the OpenGL context active if needed.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>GL_DEPTH_COMPONENT</code> format may not be supported by all hardware. It may sometimes be emulated in software, resulting in poor performances.</dd>
<dd>
The <a class="el" href="classQGLViewer.html#a6435e0a64e14d04dce25e524051f8d69">bufferTextureId()</a> texture is binded at the end of this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d52227793dba3e2f87f07acec26fd56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qreal currentFPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current averaged viewer frame rate.</p>
<p>This value is computed and averaged over 20 successive frames. It only changes every 20 <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> (previously computed value is otherwise returned).</p>
<p>This method is useful for true real-time applications that may adapt their computational load accordingly in order to maintain a given frequency.</p>
<p>This value is meaningful only when <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> is regularly called, either using a <code>QTimer</code>, when <a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a> or when the camera is manipulated with the mouse. </p>

</div>
</div>
<a class="anchor" id="a61336516f9771ac6aef90875f848add4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void displayMessage </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delay</em> = <code>2000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Briefly displays a message in the lower left corner of the widget. Convenient to provide feedback to the user.</p>
<p><code>message</code> is displayed during <code>delay</code> milliseconds (default is 2 seconds) using <a class="el" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText()</a>.</p>
<p>This method should not be called in <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. If you want to display a text in each <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>, use <a class="el" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText()</a> instead.</p>
<p>If this method is called when a message is already displayed, the new message replaces the old one. Use <a class="el" href="classQGLViewer.html#a73d76caa402acd217e504d0bcd13e421">setTextIsEnabled()</a> (default shortcut is '?') to enable or disable text (and hence messages) display. </p>

</div>
</div>
<a class="anchor" id="a2fc4c62e317a0f64c2a943ed11faa337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool displaysInStereo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the viewer displays in stereo.</p>
<p>The QGLViewer object must be created with a stereo format to handle stereovision: </p><div class="fragment"><div class="line">QGLFormat format;</div>
<div class="line">format.setStereoDisplay( TRUE );</div>
<div class="line">QGLViewer viewer(format);</div>
</div><!-- fragment --><p> The hardware needs to support stereo display. Try the <a href="../examples/stereoViewer.html">stereoViewer example</a> to check.</p>
<p>Set by <a class="el" href="classQGLViewer.html#afe362ba5c3851a93f23fb833b2479f08">setStereoDisplay()</a> or <a class="el" href="classQGLViewer.html#a4e0ebf98eacbcbad3b094e26d9e35886">toggleStereoDisplay()</a>. Default value is <code>false</code>.</p>
<p>Stereo is performed using the Parallel axis asymmetric frustum perspective projection method. See Camera::loadProjectionMatrixStereo() and Camera::loadModelViewMatrixStereo().</p>
<p>The stereo parameters are defined by the <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a>. See <a class="el" href="classqglviewer_1_1Camera.html#a90329d0edd2bdf789ca22ccee1a2d6f7">qglviewer::Camera::setIODistance()</a>, <a class="el" href="classqglviewer_1_1Camera.html#a98d2a2c7d32f5088203e010f7e563f8f">qglviewer::Camera::setPhysicalScreenWidth()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a05a5690ac023c6498cb62c13fbeb1e98">qglviewer::Camera::setFocusDistance()</a>. </p>

</div>
</div>
<a class="anchor" id="a48e0e2dd26cd96418c8b889ceabe80f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QDomElement domElement </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QDomDocument &amp;&#160;</td>
          <td class="paramname"><em>document</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an XML <code>QDomElement</code> that represents the QGLViewer.</p>
<p>Used by <a class="el" href="classQGLViewer.html#aaec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a>. <a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a> uses <a class="el" href="classQGLViewer.html#acd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement()</a> to restore the QGLViewer state from the resulting <code>QDomElement</code>.</p>
<p><code>name</code> is the name of the QDomElement tag. <code>doc</code> is the <code>QDomDocument</code> factory used to create QDomElement.</p>
<p>The created QDomElement contains state values (<a class="el" href="classQGLViewer.html#a7d38e6f11078e886f7978525def15797">axisIsDrawn()</a>, <a class="el" href="classQGLViewer.html#a4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a>, <a class="el" href="classQGLViewer.html#a129c439f36bb669672148192abc8ffed">isFullScreen()</a>...), viewer geometry, as well as <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> (see <a class="el" href="classqglviewer_1_1Camera.html#a48e0e2dd26cd96418c8b889ceabe80f6">qglviewer::Camera::domElement()</a>) and <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> (if defined, see <a class="el" href="classqglviewer_1_1ManipulatedFrame.html#a48e0e2dd26cd96418c8b889ceabe80f6">qglviewer::ManipulatedFrame::domElement()</a>) states.</p>
<p>Overload this method to add your own attributes to the state file: </p><div class="fragment"><div class="line">QDomElement Viewer::domElement(<span class="keyword">const</span> QString&amp; name, QDomDocument&amp; document)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line"><span class="comment">// Creates a custom node for a light</span></div>
<div class="line">QDomElement de = document.createElement(<span class="stringliteral">&quot;Light&quot;</span>);</div>
<div class="line">de.setAttribute(<span class="stringliteral">&quot;state&quot;</span>, (lightIsOn()?<span class="stringliteral">&quot;on&quot;</span>:<span class="stringliteral">&quot;off&quot;</span>));</div>
<div class="line"><span class="comment">// Note the include of the ManipulatedFrame domElement method.</span></div>
<div class="line">de.appendChild(lightManipulatedFrame()-&gt;<a class="code" href="classQGLViewer.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement</a>(<span class="stringliteral">&quot;LightFrame&quot;</span>, document));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get default state domElement and append custom node</span></div>
<div class="line">QDomElement res = <a class="code" href="classQGLViewer.html#a48e0e2dd26cd96418c8b889ceabe80f6">QGLViewer::domElement</a>(name, document);</div>
<div class="line">res.appendChild(de);</div>
<div class="line"><span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p> See <a class="el" href="classQGLViewer.html#acd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement()</a> for the associated restoration code.</p>
<dl class="section attention"><dt>Attention</dt><dd>For the <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>, <a class="el" href="classqglviewer_1_1Frame.html#a0974dfe336ed84a20adb8c6cdf8dedd9">qglviewer::Frame::constraint()</a> and <a class="el" href="classqglviewer_1_1Frame.html#a9794b079db5f492e8804631d3d23baec">qglviewer::Frame::referenceFrame()</a> are not saved. See <a class="el" href="classqglviewer_1_1Frame.html#a48e0e2dd26cd96418c8b889ceabe80f6">qglviewer::Frame::domElement()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abc45d04e5f5ce1fbd68f920fcdb2d0e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void draw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The core method of the viewer, that draws the scene.</p>
<p>If you build a class that inherits from QGLViewer, this is the method you want to overload. See the <a href="../examples/simpleViewer.html">simpleViewer example</a> for an illustration.</p>
<p>The camera modelView matrix set in <a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw()</a> converts from the world to the camera coordinate systems. Vertices given in <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> can then be considered as being given in the world coordinate system. The camera is moved in this world using the mouse. This representation is much more intuitive than the default camera-centric OpenGL standard.</p>
<dl class="section attention"><dt>Attention</dt><dd>The <code>GL_PROJECTION</code> matrix should not be modified by this method, to correctly display visual hints (axis, grid, FPS...) in <a class="el" href="classQGLViewer.html#a24f5dce22199f5eea71f034cae6ae4fa">postDraw()</a>. Use push/pop or call <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;loadProjectionMatrix() at the end of <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> if you need to change the projection matrix (unlikely). On the other hand, the <code>GL_MODELVIEW</code> matrix can be modified and left in a arbitrary state. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ee5a2d40e4613eb6c824311e01ce150"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawArrow </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>length</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>radius</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbSubdivisions</em> = <code>12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a 3D arrow along the positive Z axis.</p>
<p><code>length</code>, <code>radius</code> and <code>nbSubdivisions</code> define its geometry. If <code>radius</code> is negative (default), it is set to 0.05 * <code>length</code>.</p>
<p>Use drawArrow(const Vec&amp; from, const Vec&amp; to, qreal radius, int nbSubdivisions) or change the <code>ModelView</code> matrix to place the arrow in 3D.</p>
<p>Uses current color and does not modify the OpenGL state. </p>

</div>
</div>
<a class="anchor" id="a4d3e50e3881dca15e1b9641afa0054dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawArrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>radius</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbSubdivisions</em> = <code>12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a 3D arrow between the 3D point <code>from</code> and the 3D point <code>to</code>, both defined in the current ModelView coordinates system.</p>
<p>See <a class="el" href="classQGLViewer.html#a3ee5a2d40e4613eb6c824311e01ce150">drawArrow(qreal length, qreal radius, int nbSubdivisions)</a> for details. </p>

</div>
</div>
<a class="anchor" id="a3072ee7495b54d48d1a11a5bd02a25cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawAxis </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>length</em> = <code>1.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws an XYZ axis, with a given size (default is 1.0).</p>
<p>The axis position and orientation matches the current modelView matrix state: three arrows (red, green and blue) of length <code>length</code> are drawn along the positive X, Y and Z directions.</p>
<p>Use the following code to display the current position and orientation of a <a class="el" href="classqglviewer_1_1Frame.html" title="The Frame class represents a coordinate system, defined by a position and an orientation. ">qglviewer::Frame</a>: </p><div class="fragment"><div class="line">glPushMatrix();</div>
<div class="line">glMultMatrixd(frame.matrix());</div>
<div class="line"><a class="code" href="classQGLViewer.html#a3072ee7495b54d48d1a11a5bd02a25cc">QGLViewer::drawAxis</a>(<a class="code" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius</a>() / 5.0); <span class="comment">// Or any scale</span></div>
<div class="line">glPopMatrix();</div>
</div><!-- fragment --><p>The current color and line width are used to draw the X, Y and Z characters at the extremities of the three arrows. The OpenGL state is not modified by this method.</p>
<p><a class="el" href="classQGLViewer.html#a7d38e6f11078e886f7978525def15797">axisIsDrawn()</a> uses this method to draw a representation of the world coordinate system. See also <a class="el" href="classQGLViewer.html#a3ee5a2d40e4613eb6c824311e01ce150">QGLViewer::drawArrow()</a> and <a class="el" href="classQGLViewer.html#a86a359ff8c78755fca0900321293da8f">QGLViewer::drawGrid()</a>. </p>

</div>
</div>
<a class="anchor" id="afc74e28548768da157f2fe75bced2803"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawFinished </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automatic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal emitted at the end of the <a class="el" href="classQGLViewer.html#ac5cbfafb28ef4c0474ae96437294f547">QGLViewer::paintGL()</a> method, when frame is drawn.</p>
<p>Can be used to notify an image grabbing process that the image is ready. A typical example is to connect this signal to the <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> method, so that a (numbered) snapshot is generated after each new display, in order to create a movie: </p><div class="fragment"><div class="line">connect(viewer, SIGNAL(<a class="code" href="classQGLViewer.html#afc74e28548768da157f2fe75bced2803">drawFinished</a>(<span class="keywordtype">bool</span>)), SLOT(<a class="code" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot</a>(<span class="keywordtype">bool</span>)));</div>
</div><!-- fragment --><p>The <code>automatic</code> bool variable is always <code>true</code> and has been added so that the signal can be connected to <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> with an <code>automatic</code> value set to <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="a86a359ff8c78755fca0900321293da8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawGrid </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>size</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbSubdivisions</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a grid in the XY plane, centered on (0,0,0) (defined in the current coordinate system).</p>
<p><code>size</code> (OpenGL units) and <code>nbSubdivisions</code> define its geometry. Set the <code>GL_MODELVIEW</code> matrix to place and orientate the grid in 3D space (see the <a class="el" href="classQGLViewer.html#a3072ee7495b54d48d1a11a5bd02a25cc">drawAxis()</a> documentation).</p>
<p>The OpenGL state is not modified by this method. </p>

</div>
</div>
<a class="anchor" id="ae8f54947331c56ea1a2de82ecba70b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawLight </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a representation of <code>light</code>.</p>
<p>Called in <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>, this method is useful to debug or display your light setup. Light drawing depends on the type of light (point, spot, directional).</p>
<p>The method retrieves the light setup using <code>glGetLightfv</code>. Position and define your lights before calling this method.</p>
<p>Light is drawn using its diffuse color. Disabled lights are not displayed.</p>
<p>Drawing size is proportional to <a class="el" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius()</a>. Use <code>scale</code> to rescale it.</p>
<p>See the <a href="../examples/drawLight.html">drawLight example</a> for an illustration.</p>
<dl class="section attention"><dt>Attention</dt><dd>You need to enable <code>GL_COLOR_MATERIAL</code> before calling this method. <code>glColor</code> is set to the light diffuse color. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a712ca70a0b1c22af51363b786fc86e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal emitted by the default <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> method.</p>
<p>Connect this signal to your main drawing method or overload <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. See the <a href="../examples/callback.html">callback example</a> for an illustration. </p>

</div>
</div>
<a class="anchor" id="ad604ec747b161c869877fcb647a3c775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawText </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QFont &amp;&#160;</td>
          <td class="paramname"><em>fnt</em> = <code>QFont()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <code>text</code> at position <code>x</code>, <code>y</code> (expressed in screen coordinates pixels, origin in the upper left corner of the widget).</p>
<p>The default QApplication::font() is used to render the text when no <code>fnt</code> is specified. Use QApplication::setFont() to define this default font.</p>
<p>You should disable <code>GL_LIGHTING</code> and <code>GL_DEPTH_TEST</code> before this method so that colors are properly rendered.</p>
<p>This method can be used in conjunction with the <a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">qglviewer::Camera::projectedCoordinatesOf()</a> method to display a text attached to an object. In your <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> method use: </p><div class="fragment"><div class="line"><a class="code" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> screenPos = <a class="code" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">projectedCoordinatesOf</a>(myFrame.position());</div>
<div class="line"><a class="code" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText</a>((<span class="keywordtype">int</span>)screenPos[0], (<span class="keywordtype">int</span>)screenPos[1], <span class="stringliteral">&quot;My Object&quot;</span>);</div>
</div><!-- fragment --><p> See the <a href="../examples/screenCoordSystem.html">screenCoordSystem example</a> for an illustration.</p>
<p>Text is displayed only when <a class="el" href="classQGLViewer.html#a87896d67f84ddb458e1e5ab326db2631">textIsEnabled()</a> (default). This mechanism allows the user to conveniently remove all the displayed text with a single keyboard shortcut.</p>
<p>See also <a class="el" href="classQGLViewer.html#a61336516f9771ac6aef90875f848add4">displayMessage()</a> to <a class="el" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText()</a> for only a short amount of time.</p>
<p>Use QGLWidget::renderText(x,y,z, text) instead if you want to draw a text located at a specific 3D position instead of 2D screen coordinates (fixed size text, facing the camera).</p>
<p>The <code>GL_MODELVIEW</code> and <code>GL_PROJECTION</code> matrices are not modified by this method.</p>
<dl class="section attention"><dt>Attention</dt><dd>This method uses display lists to render the characters, with an index that starts at 2000 by default (see the QGLWidget::renderText() documentation). If you use more than 2000 Display Lists, they may overlap with these. Directly use QGLWidget::renderText() in that case, with a higher <code>listBase</code> parameter (or overload <code>fontDisplayListBase</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="a528b238068a87472df8ac3a5b2481c55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drawWithNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is called by <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> and should draw selectable entities.</p>
<p>Default implementation is empty. Overload and draw the different elements of your scene you want to be able to select. The default <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> implementation relies on the <code>GL_SELECT</code>, and requires that each selectable element is drawn within a <code>glPushName()</code> - <code>glPopName()</code> block. A typical usage would be (see the <a href="../examples/select.html">select example</a>): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Viewer::drawWithNames() {</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbObjects; ++i) {</div>
<div class="line">          glPushName(i);</div>
<div class="line">          object(i)-&gt;draw();</div>
<div class="line">          glPopName();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --> <pre class="fragment">    The resulting selected name is computed by endSelection(), which setSelectedName() to the integer
    id pushed by this method (a value of -1 means no selection). Use selectedName() to update your
    selection, probably in the postSelection() method.

    \attention If your selected objects are points, do not use \c glBegin(GL_POINTS); and \c glVertex3fv()
    in the above \c draw() method (not compatible with raster mode): use \c glRasterPos3fv() instead.  </pre> 
</div>
</div>
<a class="anchor" id="a0d164809a99bbe6ff2fc0dee33fe0e91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void endSelection </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is called by <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> after scene elements were drawn by <a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>. It should analyze the selection result to determine which object is actually selected.</p>
<p>The default implementation relies on <code>GL_SELECT</code> mode (see <a class="el" href="classQGLViewer.html#af0a48cc50f194926bad38d4924162116">beginSelection()</a>). It assumes that names were pushed and popped in <a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>, and analyzes the <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a> to find the name that corresponds to the closer (z min) object. It then <a class="el" href="classQGLViewer.html#aeaa1327270d0bcdf991874e7d741afd5">setSelectedName()</a> to this value, or to -1 if the <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a> is empty (no object drawn in selection region). Use <a class="el" href="classQGLViewer.html#a0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> (probably in the <a class="el" href="classQGLViewer.html#a3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection()</a> method) to retrieve this value and update your data structure accordingly.</p>
<p>This default implementation, although sufficient for many cases is however limited and you may have to overload this method. This will be the case if <a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a> uses several push levels in the name heap. A more precise depth selection, for instance privileging points over edges and triangles to avoid z precision problems, will also require an overloading. A typical implementation will look like: </p><div class="fragment"><div class="line">glFlush();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the number of objects that were seen through the pick matrix frustum.</span></div>
<div class="line"><span class="comment">// Resets GL_RENDER mode.</span></div>
<div class="line">GLint nbHits = glRenderMode(GL_RENDER);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (nbHits &lt;= 0)</div>
<div class="line"><a class="code" href="classQGLViewer.html#aeaa1327270d0bcdf991874e7d741afd5">setSelectedName</a>(-1);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line"><span class="comment">// Interpret results: each object created values in the selectBuffer().</span></div>
<div class="line"><span class="comment">// See the glSelectBuffer() man page for details on the buffer structure.</span></div>
<div class="line"><span class="comment">// The following code depends on your selectBuffer() structure.</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbHits; ++i)</div>
<div class="line"><span class="keywordflow">if</span> ((<a class="code" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer</a>())[i*4+1] &lt; zMin)</div>
<div class="line"><a class="code" href="classQGLViewer.html#aeaa1327270d0bcdf991874e7d741afd5">setSelectedName</a>((<a class="code" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer</a>())[i*4+3])</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the <a href="../examples/multiSelect.html">multiSelect example</a> for a multi-object selection implementation of this method. </p>

</div>
</div>
<a class="anchor" id="a8b6601997fe7a83e7cd041104d4b21d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fastDraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a simplified version of the scene to guarantee interactive camera displacements.</p>
<p>This method is called instead of <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> when the <a class="el" href="classqglviewer_1_1Camera.html#ad367db656b03fe0bc87b021801d66b75">qglviewer::Camera::frame()</a> is <a class="el" href="classqglviewer_1_1ManipulatedFrame.html#a032c48e2e7cdced01dea0cb7eca14022">qglviewer::ManipulatedCameraFrame::isManipulated()</a>. Default implementation simply calls <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>.</p>
<p>Overload this method if your scene is too complex to allow for interactive camera manipulation. See the <a href="../examples/fastDraw.html">fastDraw example</a> for an illustration. </p>

</div>
</div>
<a class="anchor" id="aa2f726def3615050a9c816c0ca32171d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QColor foregroundColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the foreground color used by the viewer.</p>
<p>This color is used when <a class="el" href="classQGLViewer.html#a4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a>, <a class="el" href="classQGLViewer.html#aee18c56a8321a60771b085a5fe798ee7">gridIsDrawn()</a>, to display the camera paths when the <a class="el" href="classQGLViewer.html#a1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>Each QColor component is an integer in the range 0-255. This differs from the qreal values used by <code>glColor3f()</code> which are in the range 0-1. Default value is (180, 180, 180) (light gray).</dd></dl>
<p>Use <code>qglColor(foregroundColor())</code> to set the current OpenGL color to the <a class="el" href="classQGLViewer.html#aa2f726def3615050a9c816c0ca32171d">foregroundColor()</a>.</p>
<p>See also <a class="el" href="classQGLViewer.html#a7ddf68dcfb09cc5a991a06d91cb4cc5b">backgroundColor()</a>. </p>

</div>
</div>
<a class="anchor" id="a4b8985b86aca5584d9869c8ac868984a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FPSIsDisplayed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the viewer displays the current frame rate (Frames Per Second).</p>
<p>Use QApplication::setFont() to define the display font (see <a class="el" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText()</a>).</p>
<p>Set by <a class="el" href="classQGLViewer.html#aad24c89e014de3ea16f071c3bc18f4db">setFPSIsDisplayed()</a> or <a class="el" href="classQGLViewer.html#ab8a88948237894dca2b7b57a67226d66">toggleFPSIsDisplayed()</a>. Use <a class="el" href="classQGLViewer.html#a6d52227793dba3e2f87f07acec26fd56">currentFPS()</a> to get the current FPS. Default value is <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a4b005fb3bda4582ce4ab7aeda6692699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FPSIsDisplayedChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>displayed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever <a class="el" href="classQGLViewer.html#a4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a> changes value. </p>

</div>
</div>
<a class="anchor" id="ae57d9efa984795d6cfbe85ad594f660f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getClickActionBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers &amp;&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton &amp;&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>doubleClick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons &amp;&#160;</td>
          <td class="paramname"><em>buttonsBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mouse and keyboard state that triggers <code>action</code>.</p>
<p>If such a binding exists, results are stored in the <code>key</code>, <code>modifiers</code>, <code>button</code>, <code>doubleClick</code> and <code>buttonsBefore</code> parameters. If the ClickAction <code>action</code> is not bound, <code>button</code> is set to <code>Qt::NoButton</code>. If several mouse buttons trigger in the ClickAction, one of them is returned.</p>
<p>See also <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a>, <a class="el" href="classQGLViewer.html#abcad615739f9ce3e857b94ca945deb5e">getMouseActionBinding()</a> and <a class="el" href="classQGLViewer.html#a0f5b32b9880a9f32d590871663713b78">getWheelActionBinding()</a>. </p>

</div>
</div>
<a class="anchor" id="abcad615739f9ce3e857b94ca945deb5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getMouseActionBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withConstraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers &amp;&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton &amp;&#160;</td>
          <td class="paramname"><em>button</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mouse and keyboard state that triggers <code>action</code> on <code>handler</code> <code>withConstraint</code>.</p>
<p>If such a binding exists, results are stored in the <code>key</code>, <code>modifiers</code> and <code>button</code> parameters. If the MouseAction <code>action</code> is not bound, <code>button</code> is set to <code>Qt::NoButton</code>. If several mouse and keyboard states trigger the MouseAction, one of them is returned.</p>
<p>See also <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a>, <a class="el" href="classQGLViewer.html#ae57d9efa984795d6cfbe85ad594f660f">getClickActionBinding()</a> and <a class="el" href="classQGLViewer.html#a0f5b32b9880a9f32d590871663713b78">getWheelActionBinding()</a>. </p>

</div>
</div>
<a class="anchor" id="a0f5b32b9880a9f32d590871663713b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getWheelActionBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withConstraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers &amp;&#160;</td>
          <td class="paramname"><em>modifiers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the keyboard state that triggers <code>action</code> on <code>handler</code> <code>withConstraint</code> using the mouse wheel.</p>
<p>If such a binding exists, results are stored in the <code>key</code> and <code>modifiers</code> parameters. If the MouseAction <code>action</code> is not bound, <code>key</code> is set to the illegal -1 value. If several keyboard states trigger the MouseAction, one of them is returned.</p>
<p>See also <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a>, <a class="el" href="classQGLViewer.html#ae57d9efa984795d6cfbe85ad594f660f">getClickActionBinding()</a> and <a class="el" href="classQGLViewer.html#abcad615739f9ce3e857b94ca945deb5e">getMouseActionBinding()</a>. </p>

</div>
</div>
<a class="anchor" id="aee18c56a8321a60771b085a5fe798ee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gridIsDrawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if a XY grid is drawn by the viewer.</p>
<p>Set by <a class="el" href="classQGLViewer.html#ae9dd114195dfdf82e23b5754b7c161de">setGridIsDrawn()</a> or <a class="el" href="classQGLViewer.html#a8dfaa8be71152ae881b9347235ccc6a1">toggleGridIsDrawn()</a>. Default value is <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="a02d191cc46db491d9807266fe62b6178"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gridIsDrawnChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drawn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever <a class="el" href="classQGLViewer.html#aee18c56a8321a60771b085a5fe798ee7">gridIsDrawn()</a> changes value. </p>

</div>
</div>
<a class="anchor" id="a47c0968a61bcd23c491817631e4ec953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hasMouseTracking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <a class="el" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> is called even when no mouse button is pressed.</p>
<p>You need to <a class="el" href="classQGLViewer.html#acf0a4ee197fe91b8c07dd74cad1aafaa">setMouseTracking()</a> to <code>true</code> in order to use MouseGrabber (see <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a>). See details in the QWidget documentation. </p>

</div>
</div>
<a class="anchor" id="ae26bcfe2f33f5873dbdfb6948cf1f59f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns viewer's widget height (in pixels). See QGLWidget documentation. </p>

</div>
</div>
<a class="anchor" id="a97ee70a8770dc30d06c744b24eb2fcfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void help </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens a modal help window that includes four tabs, respectively filled with <a class="el" href="classQGLViewer.html#a38ddb3cdf15e24de824a2d7a170ec915">helpString()</a>, <a class="el" href="classQGLViewer.html#a0e20e13c1170d50b46b6fe2a49377690">keyboardString()</a>, <a class="el" href="classQGLViewer.html#a6d66b99a4c5a38ef0072f350b055201b">mouseString()</a> and about libQGLViewer.</p>
<p>Rich html-like text can be used (see the QStyleSheet documentation). This method is called when the user presses the <a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a9f5cb747b2e1f0ea781d2b1f2a5b4824">HELP</a> key (default is 'H').</p>
<p>You can use <a class="el" href="classQGLViewer.html#af3af989be04f1d45b6ff3f748c2e9d4a">helpWidget()</a> to access to the help widget (to add/remove tabs, change layout...).</p>
<p>The <a class="el" href="classQGLViewer.html#a64f461121859dc0c19e7af2d413935e0">helpRequired()</a> signal is emitted. </p>

</div>
</div>
<a class="anchor" id="a64f461121859dc0c19e7af2d413935e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helpRequired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal emitted by the default <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">QGLViewer::help()</a> method.</p>
<p>Connect this signal to your own help method or overload <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a>. </p>

</div>
</div>
<a class="anchor" id="a38ddb3cdf15e24de824a2d7a170ec915"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QString helpString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the QString displayed in the <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window main tab.</p>
<p>Overload this method to define your own help string, which should shortly describe your application and explain how it works. Rich-text (HTML) tags can be used (see QStyleSheet() documentation for available tags): </p><div class="fragment"><div class="line">QString myViewer::helpString()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">QString text(<span class="stringliteral">&quot;&lt;h2&gt;M y V i e w e r&lt;/h2&gt;&quot;</span>);</div>
<div class="line">text += <span class="stringliteral">&quot;Displays a &lt;b&gt;Scene&lt;/b&gt; using OpenGL. Move the camera using the mouse.&quot;</span>;</div>
<div class="line"><span class="keywordflow">return</span> text;</div>
<div class="line">}</div>
</div><!-- fragment --><p>See also <a class="el" href="classQGLViewer.html#a6d66b99a4c5a38ef0072f350b055201b">mouseString()</a> and <a class="el" href="classQGLViewer.html#a0e20e13c1170d50b46b6fe2a49377690">keyboardString()</a>. </p>

</div>
</div>
<a class="anchor" id="af3af989be04f1d45b6ff3f748c2e9d4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QTabWidget* helpWidget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the help widget.</p>
<p>Use this only if you want to directly modify the help widget. Otherwise use <a class="el" href="classQGLViewer.html#a38ddb3cdf15e24de824a2d7a170ec915">helpString()</a>, <a class="el" href="classQGLViewer.html#ae33368bc379da582a3d26df18a6df16c">setKeyDescription()</a> and <a class="el" href="classQGLViewer.html#ae6952d2191d9e47e295fb53248d47702">setMouseBindingDescription()</a> to customize the text displayed in the help window tabs. </p>

</div>
</div>
<a class="anchor" id="a9339772ec5ac9fa929938109207f2863"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the viewer OpenGL context.</p>
<p>This method is called before the first drawing and should be overloaded to initialize some of the OpenGL flags. The default implementation is empty. See <a class="el" href="classQGLViewer.html#a2d3d45239c78255c23a70ca558b4d4f1">initializeGL()</a>.</p>
<p>Typical usage include <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> initialization (<a class="el" href="classQGLViewer.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a>), previous viewer state restoration (<a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a>), OpenGL state modification and display list creation.</p>
<p>Note that <a class="el" href="classQGLViewer.html#a2d3d45239c78255c23a70ca558b4d4f1">initializeGL()</a> modifies the standard OpenGL context. These values can be restored back in this method.</p>
<dl class="section attention"><dt>Attention</dt><dd>You should not call <a class="el" href="classQGLViewer.html#ae12b7378efbffabc24a133ca1deb19ae">updateGL()</a> (or any method that calls it) in this method, as it will result in an infinite loop. The different QGLViewer set methods (<a class="el" href="classQGLViewer.html#a5be8cff3702c1a130f8a17330737a887">setAxisIsDrawn()</a>, <a class="el" href="classQGLViewer.html#aad24c89e014de3ea16f071c3bc18f4db">setFPSIsDisplayed()</a>...) are protected against this problem and can safely be called.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All the OpenGL specific initializations must be done in this method: the OpenGL context is not yet available in your viewer constructor. </dd></dl>

</div>
</div>
<a class="anchor" id="acd13d2ddeca530cb9f26ead47f7d25d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initFromDOMElement </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restores the QGLViewer state from a <code>QDomElement</code> created by <a class="el" href="classQGLViewer.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a>.</p>
<p>Used by <a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a> to restore the QGLViewer state from a file.</p>
<p>Overload this method to retrieve custom attributes from the QGLViewer state file. This code corresponds to the one given in the <a class="el" href="classQGLViewer.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a> documentation: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Viewer::initFromDOMElement(<span class="keyword">const</span> QDomElement&amp; element)</div>
<div class="line">{</div>
<div class="line"><span class="comment">// Restore standard state</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#acd13d2ddeca530cb9f26ead47f7d25d3">QGLViewer::initFromDOMElement</a>(element);</div>
<div class="line"></div>
<div class="line">QDomElement child=element.firstChild().toElement();</div>
<div class="line"><span class="keywordflow">while</span> (!child.isNull())</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">if</span> (child.tagName() == <span class="stringliteral">&quot;Light&quot;</span>)</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">if</span> (child.hasAttribute(<span class="stringliteral">&quot;state&quot;</span>))</div>
<div class="line">setLightOn(child.attribute(<span class="stringliteral">&quot;state&quot;</span>).lower() == <span class="stringliteral">&quot;on&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Assumes there is only one child. Otherwise you need to parse child&#39;s children recursively.</span></div>
<div class="line">QDomElement lf = child.firstChild().toElement();</div>
<div class="line"><span class="keywordflow">if</span> (!lf.isNull() &amp;&amp; lf.tagName() == <span class="stringliteral">&quot;LightFrame&quot;</span>)</div>
<div class="line">lightManipulatedFrame()-&gt;initFromDomElement(lf);</div>
<div class="line">}</div>
<div class="line">child = child.nextSibling().toElement();</div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p>See also <a class="el" href="classqglviewer_1_1Camera.html#acd13d2ddeca530cb9f26ead47f7d25d3">qglviewer::Camera::initFromDOMElement()</a>, <a class="el" href="classqglviewer_1_1ManipulatedFrame.html#acd13d2ddeca530cb9f26ead47f7d25d3">qglviewer::ManipulatedFrame::initFromDOMElement()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> <em>pointer</em> is not modified by this method. If defined, its state is simply set from the <code>element</code> values. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d3d45239c78255c23a70ca558b4d4f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initializeGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the QGLViewer OpenGL context and then calls user-defined <a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">init()</a>.</p>
<p>This method is automatically called once, before the first call to <a class="el" href="classQGLViewer.html#ac5cbfafb28ef4c0474ae96437294f547">paintGL()</a>.</p>
<p>Overload <a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">init()</a> instead of this method to modify viewer specific OpenGL state or to create display lists.</p>
<p>To make beginners' life easier and to simplify the examples, this method slightly modifies the standard OpenGL state: </p><div class="fragment"><div class="line">glEnable(GL_LIGHT0);</div>
<div class="line">glEnable(GL_LIGHTING);</div>
<div class="line">glEnable(GL_DEPTH_TEST);</div>
<div class="line">glEnable(GL_COLOR_MATERIAL);</div>
</div><!-- fragment --><p>If you port an existing application to QGLViewer and your display changes, you probably want to disable these flags in <a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">init()</a> to get back to a standard OpenGL state. </p>

</div>
</div>
<a class="anchor" id="a129c439f36bb669672148192abc8ffed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isFullScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the viewer is in fullScreen mode.</p>
<p>Default value is <code>false</code>. Set by <a class="el" href="classQGLViewer.html#a7e021e15180ba348e90c955bdd28b1a4">setFullScreen()</a> or <a class="el" href="classQGLViewer.html#aa5b47397e4ad7c2bb9573e0d186170e0">toggleFullScreen()</a>.</p>
<p>Note that if the QGLViewer is embedded in an other QWidget, it returns <code>true</code> when the top level widget is in full screen mode. </p>

</div>
</div>
<a class="anchor" id="a514d24ec3ec6c94657ef302a2b3fa74a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSharing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if display list sharing with another QGLWidget was requested in the constructor. See QGLWidget documentation. </p>

</div>
</div>
<a class="anchor" id="aac1b70a2ed67ead038c4d3f5ac4d8a81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the widget has a valid GL rendering context. See QGLWidget documentation. </p>

</div>
</div>
<a class="anchor" id="a0e20e13c1170d50b46b6fe2a49377690"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString keyboardString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a QString that describes the application keyboard shortcut bindings, and that will be displayed in the <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window <code>Keyboard</code> tab.</p>
<p>Default value is a table that describes the custom shortcuts defined using <a class="el" href="classQGLViewer.html#ae33368bc379da582a3d26df18a6df16c">setKeyDescription()</a> as well as the <em>standard</em> <a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">QGLViewer::KeyboardAction</a> shortcuts (defined using <a class="el" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut()</a>). See the <a href="../keyboard.html">keyboard page</a> for details on key customization.</p>
<p>See also <a class="el" href="classQGLViewer.html#a38ddb3cdf15e24de824a2d7a170ec915">helpString()</a> and <a class="el" href="classQGLViewer.html#a6d66b99a4c5a38ef0072f350b055201b">mouseString()</a>. </p>

</div>
</div>
<a class="anchor" id="a2cc4c898ca007c7cc0ebb7791aa3e5b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void keyPressEvent </td>
          <td>(</td>
          <td class="paramtype">QKeyEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloading of the <code>QWidget</code> method.</p>
<p>Default keyboard shortcuts are defined using <a class="el" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut()</a>. Overload this method to implement a specific keyboard binding. Call the original method if you do not catch the event to preserve the viewer default key bindings: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Viewer::keyPressEvent(QKeyEvent *e)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Defines the Alt+R shortcut.</span></div>
<div class="line">  <span class="keywordflow">if</span> ((e-&gt;key() == Qt::Key_R) &amp;&amp; (e-&gt;modifiers() == Qt::AltModifier))</div>
<div class="line">  {</div>
<div class="line">        myResetFunction();</div>
<div class="line">        update(); <span class="comment">// Refresh display</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">        <a class="code" href="classQGLViewer.html#a2cc4c898ca007c7cc0ebb7791aa3e5b3">QGLViewer::keyPressEvent</a>(e);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// With Qt 2 or 3, you would retrieve modifiers keys using :</span></div>
<div class="line"><span class="comment">// const Qt::ButtonState modifiers = (Qt::ButtonState)(e-&gt;state() &amp; Qt::KeyButtonMask);</span></div>
</div><!-- fragment --><p> When you define a new keyboard shortcut, use <a class="el" href="classQGLViewer.html#ae33368bc379da582a3d26df18a6df16c">setKeyDescription()</a> to provide a short description which is displayed in the <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window Keyboard tab. See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for an illustration.</p>
<p>See also QGLWidget::keyReleaseEvent(). </p>

</div>
</div>
<a class="anchor" id="a3bbb1d9848e9f0625bd0a7252e86de94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void keyReleaseEvent </td>
          <td>(</td>
          <td class="paramtype">QKeyEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1436277e13026c94601bbe37a2f1d262"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void makeCurrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes this widget's rendering context the current OpenGL rendering context. Useful with several viewers. See QGLWidget documentation. </p>

</div>
</div>
<a class="anchor" id="aba8c9c519574192fb7197bdbad8049db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a>* manipulatedFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the viewer's <a class="el" href="classqglviewer_1_1ManipulatedFrame.html" title="A ManipulatedFrame is a Frame that can be rotated and translated using the mouse. ...">qglviewer::ManipulatedFrame</a>.</p>
<p>This <a class="el" href="classqglviewer_1_1ManipulatedFrame.html" title="A ManipulatedFrame is a Frame that can be rotated and translated using the mouse. ...">qglviewer::ManipulatedFrame</a> can be moved with the mouse when the associated mouse bindings are used (default is when pressing the <code>Control</code> key with any mouse button). Use <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a> to define new bindings.</p>
<p>See the <a href="../examples/manipulatedFrame.html">manipulatedFrame example</a> for a complete implementation.</p>
<p>Default value is <code>NULL</code>, meaning that no <a class="el" href="classqglviewer_1_1ManipulatedFrame.html" title="A ManipulatedFrame is a Frame that can be rotated and translated using the mouse. ...">qglviewer::ManipulatedFrame</a> is set. </p>

</div>
</div>
<a class="anchor" id="ab689056381e744de41ccc27383294692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">QGLViewer::MouseAction</a> mouseAction </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is deprecated since version 2.5.0</p>
<p>Use mouseAction(Qt::Key, Qt::KeyboardModifiers, Qt::MouseButtons) instead.</p>
<p>Returns the MouseAction the will be triggered when the mouse <code>button</code> is pressed, while the keyboard <code>modifiers</code> and <code>key</code> are pressed.</p>
<p>Returns <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3b20d5f27f63af5ea6e5b6af1112ecf8">NO_MOUSE_ACTION</a> if no action is associated with this combination. Use 0 for <code>key</code> to indicate that no regular key needs to be pressed.</p>
<p>For instance, to know which motion corresponds to Alt+LeftButton, do: </p><div class="fragment"><div class="line"><a class="code" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">QGLViewer::MouseAction</a> ma = <a class="code" href="classQGLViewer.html#ab689056381e744de41ccc27383294692">mouseAction</a>(0, Qt::AltModifier, Qt::LeftButton);</div>
<div class="line"><span class="keywordflow">if</span> (ma != <a class="code" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3b20d5f27f63af5ea6e5b6af1112ecf8">NO_MOUSE_ACTION</a>) ...</div>
</div><!-- fragment --><p>Use <a class="el" href="classQGLViewer.html#a692798e25eba7676d441fabd153dc77c">mouseHandler()</a> to know which object (<a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325dada31f516cdf218b68b790fb31e8a6956">CAMERA</a> or <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325da200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>) will execute this action. </p>

</div>
</div>
<a class="anchor" id="aa11ba8137b62942cede01c57aade3073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mouseDoubleClickEvent </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloading of the <code>QWidget</code> method.</p>
<p>The behavior of the mouse double click depends on the mouse binding. See <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a> and the <a href="../mouse.html">mouse page</a>. </p>

</div>
</div>
<a class="anchor" id="a6c834adafd727025b63741dd27cb6925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a>* mouseGrabber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current <a class="el" href="classqglviewer_1_1MouseGrabber.html" title="Abstract class for objects that grab mouse focus in a QGLViewer. ">qglviewer::MouseGrabber</a>, or <code>NULL</code> if no <a class="el" href="classqglviewer_1_1MouseGrabber.html" title="Abstract class for objects that grab mouse focus in a QGLViewer. ">qglviewer::MouseGrabber</a> currently grabs mouse events.</p>
<p>When <a class="el" href="classqglviewer_1_1MouseGrabber.html#a4eb7e14d035ae255b77ac1711aef039e">qglviewer::MouseGrabber::grabsMouse()</a>, the different mouse events are sent to the <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> instead of their usual targets (<a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> or <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>).</p>
<p>See the <a class="el" href="classqglviewer_1_1MouseGrabber.html" title="Abstract class for objects that grab mouse focus in a QGLViewer. ">qglviewer::MouseGrabber</a> documentation for details on MouseGrabber's mode of operation.</p>
<p>In order to use MouseGrabbers, you need to enable mouse tracking (so that <a class="el" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> is called even when no mouse button is pressed). Add this line in <a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">init()</a> or in your viewer constructor: </p><div class="fragment"><div class="line"><a class="code" href="classQGLViewer.html#acf0a4ee197fe91b8c07dd74cad1aafaa">setMouseTracking</a>(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p> Note that mouse tracking is disabled by default. Use QWidget::hasMouseTracking() to retrieve current state. </p>

</div>
</div>
<a class="anchor" id="a959ca6df1731d57aa692af99abcd28d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mouseGrabberChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *&#160;</td>
          <td class="paramname"><em>mouseGrabber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal emitted by <a class="el" href="classQGLViewer.html#a993285ef8a16ccbdc5d57a1264212712">setMouseGrabber()</a> when the <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> is changed.</p>
<p><code>mouseGrabber</code> is a pointer to the new MouseGrabber. Note that this signal is emitted with a <code>NULL</code> parameter each time a MouseGrabber stops grabbing mouse. </p>

</div>
</div>
<a class="anchor" id="a5fe9b0a1fcd39a5cb132ffdc86f2574f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mouseGrabberIsEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *const&#160;</td>
          <td class="paramname"><em>mouseGrabber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <code>mouseGrabber</code> is enabled.</p>
<p>Default value is <code>true</code> for all MouseGrabbers. When set to <code>false</code> using <a class="el" href="classQGLViewer.html#a3f0b956f948f469c095ff3c2c1b73494">setMouseGrabberIsEnabled()</a>, the specified <code>mouseGrabber</code> will never become the <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> of this QGLViewer. This is useful when you use several viewers: some MouseGrabbers may only have a meaning for some specific viewers and should not be selectable in others.</p>
<p>You can also use <a class="el" href="classqglviewer_1_1MouseGrabber.html#a4ac2261aafd5f48f2d90c989cdd69369">qglviewer::MouseGrabber::removeFromMouseGrabberPool()</a> to completely disable a MouseGrabber in all the QGLViewers. </p>

</div>
</div>
<a class="anchor" id="a692798e25eba7676d441fabd153dc77c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mouseHandler </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is deprecated since version 2.5.0</p>
<p>Use mouseHanler(Qt::Key, Qt::KeyboardModifiers, Qt::MouseButtons) instead.</p>
<p>Returns the MouseHandler which will be activated when the mouse <code>button</code> is pressed, while the <code>modifiers</code> and <code>key</code> are pressed.</p>
<p>If no action is associated with this combination, returns <code>-1</code>. Use 0 for <code>key</code> and Qt::NoModifier for <code>modifiers</code> to represent the lack of a key press.</p>
<p>For instance, to know which handler receives the Alt+LeftButton, do: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> mh = <a class="code" href="classQGLViewer.html#a692798e25eba7676d441fabd153dc77c">mouseHandler</a>(0, Qt::AltModifier, Qt::LeftButton);</div>
<div class="line"><span class="keywordflow">if</span> (mh == <a class="code" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325dada31f516cdf218b68b790fb31e8a6956">CAMERA</a>) ...</div>
</div><!-- fragment --><p>Use <a class="el" href="classQGLViewer.html#ab689056381e744de41ccc27383294692">mouseAction()</a> to know which action (see the MouseAction enum) will be performed on this handler. </p>

</div>
</div>
<a class="anchor" id="a88e672693c2cfdbaf9af942a58a8e1dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mouseMoveEvent </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloading of the <code>QWidget</code> method.</p>
<p>Mouse move event is sent to the <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> (if any) or to the <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> or the <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>, depending on mouse bindings (see <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a>).</p>
<p>If you want to define your own mouse behavior, do something like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Viewer::mousePressEvent(QMouseEvent* e)</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ((e-&gt;button() == myButton) &amp;&amp; (e-&gt;modifiers() == myModifiers))</div>
<div class="line">  myMouseBehavior = <span class="keyword">true</span>;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <a class="code" href="classQGLViewer.html#a991f0a076bd76a1ee5bda0df7fa474f4">QGLViewer::mousePressEvent</a>(e);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Viewer::mouseMoveEvent(QMouseEvent *e)</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">if</span> (myMouseBehavior)</div>
<div class="line">  <span class="comment">// Use e-&gt;x() and e-&gt;y() as you want...</span></div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <a class="code" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">QGLViewer::mouseMoveEvent</a>(e);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Viewer::mouseReleaseEvent(QMouseEvent* e)</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">if</span> (myMouseBehavior)</div>
<div class="line">  myMouseBehavior = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <a class="code" href="classQGLViewer.html#a158642bef03883cc4157b8b40e1aa0ea">QGLViewer::mouseReleaseEvent</a>(e);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a991f0a076bd76a1ee5bda0df7fa474f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mousePressEvent </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloading of the <code>QWidget</code> method.</p>
<p>When the user clicks on the mouse: </p><ul>
<li>if a <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> is defined, <a class="el" href="classqglviewer_1_1MouseGrabber.html#a56df172a6eff56ecc1a99d2e7d548d31">qglviewer::MouseGrabber::mousePressEvent()</a> is called, </li>
<li>otherwise, the <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> or the <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> interprets the mouse displacements, depending on mouse bindings.</li>
</ul>
<p>Mouse bindings customization can be achieved using <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a>. See the <a href="../mouse.html">mouse page</a> for a complete description of mouse bindings.</p>
<p>See the <a class="el" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> documentation for an example of more complex mouse behavior customization using overloading.</p>
<dl class="section note"><dt>Note</dt><dd>When the <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a> is a <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>, the modifier keys are not taken into account. This allows for a direct manipulation of the <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> when the mouse hovers, which is probably what is expected. </dd></dl>

</div>
</div>
<a class="anchor" id="a158642bef03883cc4157b8b40e1aa0ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mouseReleaseEvent </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloading of the <code>QWidget</code> method.</p>
<p>Calls the <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a>, <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> or manipulatedFrame <code>mouseReleaseEvent</code> method.</p>
<p>See the <a class="el" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> documentation for an example of mouse behavior customization. </p>

</div>
</div>
<a class="anchor" id="a6d66b99a4c5a38ef0072f350b055201b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString mouseString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a QString that describes the application mouse bindings, displayed in the <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window <code>Mouse</code> tab.</p>
<p>Result is a table that describes custom application mouse binding descriptions defined using <a class="el" href="classQGLViewer.html#ae6952d2191d9e47e295fb53248d47702">setMouseBindingDescription()</a> as well as standard mouse bindings (defined using <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a>). See the <a href="../mouse.html">mouse page</a> for details on mouse bindings.</p>
<p>See also <a class="el" href="classQGLViewer.html#a38ddb3cdf15e24de824a2d7a170ec915">helpString()</a> and <a class="el" href="classQGLViewer.html#a0e20e13c1170d50b46b6fe2a49377690">keyboardString()</a>. </p>

</div>
</div>
<a class="anchor" id="ac9c409fd034bc5ab42aacfa4c23fe55c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openSnapshotFormatDialog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens a dialog that displays the different available snapshot formats.</p>
<p>Then calls <a class="el" href="classQGLViewer.html#a82043998256d08163f79ceee83278e14">setSnapshotFormat()</a> with the selected one (unless the user cancels).</p>
<p>Returns <code>false</code> if the user presses the Cancel button and <code>true</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac5cbfafb28ef4c0474ae96437294f547"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void paintGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Main paint method, inherited from <code>QGLWidget</code>.</p>
<p>Calls the following methods, in that order: </p><ul>
<li><a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw()</a> (or <a class="el" href="classQGLViewer.html#a43df4754781c2aaf3236d676401cec59">preDrawStereo()</a> if viewer <a class="el" href="classQGLViewer.html#a2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a>) : places the camera in the world coordinate system. </li>
<li><a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> (or <a class="el" href="classQGLViewer.html#a8b6601997fe7a83e7cd041104d4b21d2">fastDraw()</a> when the camera is manipulated) : main drawing method. Should be overloaded. </li>
<li><a class="el" href="classQGLViewer.html#a24f5dce22199f5eea71f034cae6ae4fa">postDraw()</a> : display of visual hints (world axis, FPS...) </li>
</ul>

</div>
</div>
<a class="anchor" id="aab5d27e632d4a2116e602bc67005b0e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Qt::Key pathKey </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the keyboard key associated to camera Key Frame path <code>index</code>.</p>
<p>Default values are F1..F12 for indexes 1..12.</p>
<p><a class="el" href="classQGLViewer.html#aad35c97454fee139eb809488ca7a8cb1">addKeyFrameKeyboardModifiers()</a> (resp. <a class="el" href="classQGLViewer.html#a53cd07399d3ed7b88cdf69d9cd17488d">playPathKeyboardModifiers()</a>) define the state key(s) that must be pressed with this key to add a KeyFrame to (resp. to play) the associated Key Frame path. If you quickly press twice the <a class="el" href="classQGLViewer.html#aab5d27e632d4a2116e602bc67005b0e5">pathKey()</a>, the path is reset (resp. deleted).</p>
<p>Use <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;keyFrameInterpolator( <code>index</code> ) to retrieve the KeyFrameInterpolator that defines the path.</p>
<p>If several keys are binded to a given <code>index</code> (see <a class="el" href="classQGLViewer.html#a5542c73a9c2c62be3cde9144d950fd13">setPathKey()</a>), one of them is returned. Returns <code>0</code> if no key is associated with this index.</p>
<p>See also the <a href="../keyboard.html">keyboard page</a>. </p>

</div>
</div>
<a class="anchor" id="a53cd07399d3ed7b88cdf69d9cd17488d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Qt::KeyboardModifiers playPathKeyboardModifiers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the keyboard modifiers that must be pressed with a <a class="el" href="classQGLViewer.html#aab5d27e632d4a2116e602bc67005b0e5">pathKey()</a> to play a camera KeyFrame path.</p>
<p>It can be <code>Qt::NoModifier</code>, <code>Qt::ControlModifier</code>, <code>Qt::ShiftModifier</code>, <code>Qt::AltModifier</code>, <code>Qt::MetaModifier</code> or a combination of these (using the bitwise '|' operator).</p>
<p>Default value is Qt::NoModifier. Defined using <a class="el" href="classQGLViewer.html#ab8e16934baadfe8db4f68dedc98075a1">setPlayPathKeyboardModifiers()</a>.</p>
<p>See also <a class="el" href="classQGLViewer.html#aad35c97454fee139eb809488ca7a8cb1">addKeyFrameKeyboardModifiers()</a>. </p>

</div>
</div>
<a class="anchor" id="ab78f96913c9aede4854b0efccf53f983"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pointSelected </td>
          <td>(</td>
          <td class="paramtype">const QMouseEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal emitted by <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a>.</p>
<p>Connect this signal to your selection method or overload <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a>, or more probably simply <a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>. </p>

</div>
</div>
<a class="anchor" id="a24f5dce22199f5eea71f034cae6ae4fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void postDraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> to draw viewer visual hints.</p>
<p>Default implementation displays axis, grid, FPS... when the respective flags are sets.</p>
<p>See the <a href="../examples/multiSelect.html">multiSelect</a> and <a href="../examples/contribs.html#thumbnail">thumbnail</a> examples for an overloading illustration.</p>
<p>The GLContext (color, LIGHTING, BLEND...) is <em>not</em> modified by this method, so that in <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>, the user can rely on the OpenGL context he defined. Respect this convention (by pushing/popping the different attributes) if you overload this method. </p>

</div>
</div>
<a class="anchor" id="a3dc0d3b212e04bcafd63e9c3eb214a6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void postSelection </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is called at the end of the <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> procedure. It should finalize the selection process and update the data structure/interface/computation/display... according to the newly selected entity.</p>
<p>The default implementation is empty. Overload this method if needed, and use <a class="el" href="classQGLViewer.html#a0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> to retrieve the selected entity name (returns -1 if no object was selected). See the <a href="../examples/select.html">select example</a> for an illustration. </p>

</div>
</div>
<a class="anchor" id="a9c6b3ec107b4f010cf1fcd8c51ca92e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void preDraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets OpenGL state before <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>.</p>
<p>Default behavior clears screen and sets the projection and modelView matrices: </p><div class="fragment"><div class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#a98a0679a22f005bbd8cc19756507cc9a">loadProjectionMatrix</a>();</div>
<div class="line"><a class="code" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#a81053f822008b76bff7b1a41dceedf53">loadModelViewMatrix</a>();</div>
</div><!-- fragment --><p>Emits the <a class="el" href="classQGLViewer.html#a7a712ca70a0b1c22af51363b786fc86e">drawNeeded()</a> signal once this is done (see the <a href="../examples/callback.html">callback example</a>). </p>

</div>
</div>
<a class="anchor" id="a43df4754781c2aaf3236d676401cec59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void preDrawStereo </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leftBuffer</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> (instead of <a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw()</a>) when viewer <a class="el" href="classQGLViewer.html#a2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a>.</p>
<p>Same as <a class="el" href="classQGLViewer.html#a9c6b3ec107b4f010cf1fcd8c51ca92e4">preDraw()</a> except that the glDrawBuffer() is set to <code>GL_BACK_LEFT</code> or <code>GL_BACK_RIGHT</code> depending on <code>leftBuffer</code>, and it uses <a class="el" href="classqglviewer_1_1Camera.html#a79dac3c1bcb983c9025710b333f063a3">qglviewer::Camera::loadProjectionMatrixStereo()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a47c0f19a566d045a2872b44014be8392">qglviewer::Camera::loadModelViewMatrixStereo()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a88b363f05e720484cde551d5f798e69b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qglClearColor </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <code>glClearColor</code>. See QGLWidget documentation. </p>

</div>
</div>
<a class="anchor" id="a8911f3aec33c17d1eba4390436b5c868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qglColor </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <code>glColor3</code>. See QGLWidget::qglColor(). </p>

</div>
</div>
<a class="anchor" id="a9570ddcbaab08bce6f121e69db4fb903"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int QGLViewerIndex </td>
          <td>(</td>
          <td class="paramtype">const QGLViewer *const&#160;</td>
          <td class="paramname"><em>viewer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the index of the QGLViewer <code>viewer</code> in the <a class="el" href="classQGLViewer.html#a32d7a506084c50fd97a24f94d9ca4864">QGLViewerPool()</a>. This index in unique and can be used to identify the different created QGLViewers (see <a class="el" href="classQGLViewer.html#a62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> for an application example).</p>
<p>When a QGLViewer is deleted, the QGLViewers' indexes are preserved and NULL is set for that index. When a QGLViewer is created, it is placed in the first available position in that list. Returns -1 if the QGLViewer could not be found (which should not be possible). </p>

</div>
</div>
<a class="anchor" id="a32d7a506084c50fd97a24f94d9ca4864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const QList&lt;QGLViewer*&gt;&amp; QGLViewerPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code>QList</code> that contains pointers to all the created QGLViewers. Note that this list may contain <code>NULL</code> pointers if the associated viewer has been deleted.</p>
<p>Can be useful to apply a method or to connect a signal to all the viewers: </p><div class="fragment"><div class="line"><span class="keywordflow">foreach</span> (QGLViewer* viewer, <a class="code" href="classQGLViewer.html#a32d7a506084c50fd97a24f94d9ca4864">QGLViewer::QGLViewerPool</a>())</div>
<div class="line">  connect(myObject, SIGNAL(IHaveChangedSignal()), viewer, SLOT(update()));</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>With Qt version 3, this method returns a <code>QPtrList</code> instead. Use a <code>QPtrListIterator</code> to iterate on the list instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1185e99a9efec124b7a9bede84a6cf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the widget to size <code>width</code> by <code>height</code> pixels. See also <a class="el" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width()</a> and <a class="el" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height()</a>. </p>

</div>
</div>
<a class="anchor" id="a3efe88f982dbec7825725dd954991139"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resizeGL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback method used when the widget size is modified.</p>
<p>If you overload this method, first call the inherited method. Also called when the widget is created, before its first display. </p>

</div>
</div>
<a class="anchor" id="a212f6b7b669463c2151688f629d72a81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool restoreStateFromFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restores the QGLViewer state from the <a class="el" href="classQGLViewer.html#a62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> file using <a class="el" href="classQGLViewer.html#acd13d2ddeca530cb9f26ead47f7d25d3">initFromDOMElement()</a>.</p>
<p>States are saved using <a class="el" href="classQGLViewer.html#aaec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a>, which is automatically called on viewer exit.</p>
<p>Returns <code>true</code> when the restoration is successful. Possible problems are an non existing or unreadable <a class="el" href="classQGLViewer.html#a62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> file, an empty <a class="el" href="classQGLViewer.html#a62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> or an XML syntax error.</p>
<p>A <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> should be defined <em>before</em> calling this method, so that its state can be restored. Initialization code put <em>after</em> this function will override saved values: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Viewer::init()</div>
<div class="line">{</div>
<div class="line"><span class="comment">// Default initialization goes here (including the declaration of a possible manipulatedFrame).</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile</a>())</div>
<div class="line"><a class="code" href="classQGLViewer.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene</a>(); <span class="comment">// Previous state cannot be restored: fit camera to scene.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Specific initialization that overrides file savings goes here.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1cf2ffb973b096b249dc7e90327a2a8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saveSnapshot </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automatic</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves a snapshot of the current image displayed by the widget.</p>
<p>Options are set using <a class="el" href="classQGLViewer.html#abbb1add55632dced395e2f1b78ef491c">snapshotFormat()</a>, <a class="el" href="classQGLViewer.html#a00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a> and <a class="el" href="classQGLViewer.html#a50685165e76c57dc87dea3c84b7e5be0">snapshotQuality()</a>. For non vectorial image formats, the image size is equal to the current viewer's dimensions (see <a class="el" href="classQGLViewer.html#a369399896761e31ae71db57fdd0ba431">width()</a> and <a class="el" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height()</a>). See <a class="el" href="classQGLViewer.html#abbb1add55632dced395e2f1b78ef491c">snapshotFormat()</a> for details on supported formats.</p>
<p>If <code>automatic</code> is <code>false</code> (or if <a class="el" href="classQGLViewer.html#a00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a> is empty), a file dialog is opened to ask for the file name.</p>
<p>When <code>automatic</code> is <code>true</code>, the file name is set to <code>NAME-NUMBER</code>, where <code>NAME</code> is <a class="el" href="classQGLViewer.html#a00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a> and <code>NUMBER</code> is <a class="el" href="classQGLViewer.html#a4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a>. The <a class="el" href="classQGLViewer.html#a4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a> is automatically incremented after each snapshot saving. This is useful to create videos from your application: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Viewer::init()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQGLViewer.html#ad1185e99a9efec124b7a9bede84a6cf1">resize</a>(720, 576); <span class="comment">// PAL DV format (use 720x480 for NTSC DV)</span></div>
<div class="line">  connect(<span class="keyword">this</span>, SIGNAL(<a class="code" href="classQGLViewer.html#afc74e28548768da157f2fe75bced2803">drawFinished</a>(<span class="keywordtype">bool</span>)), SLOT(<a class="code" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot</a>(<span class="keywordtype">bool</span>)));</div>
<div class="line">}</div>
</div><!-- fragment --><p> Then call <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> in a loop (for instance using <a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and/or a <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> KeyFrameInterpolator replay) to create your image sequence.</p>
<p>If you want to create a Quicktime VR panoramic sequence, simply use code like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Viewer::createQuicktime()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nbImages = 36;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nbImages; ++i)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera</a>()-&gt;<a class="code" href="classqglviewer_1_1Camera.html#a3862c502f5afc626af2ff582390bc868">setOrientation</a>(2.0*M_PI/nbImages, 0.0); <span class="comment">// Theta-Phi orientation</span></div>
<div class="line">          <a class="code" href="classQGLViewer.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene</a>();</div>
<div class="line">          update(); <span class="comment">// calls draw(), which emits drawFinished(), which calls saveSnapshot()</span></div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If <a class="el" href="classQGLViewer.html#a4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a> is negative, no number is appended to <a class="el" href="classQGLViewer.html#a00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a> and the <a class="el" href="classQGLViewer.html#a4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a> is not incremented. This is useful to force the creation of a file, overwriting the previous one.</p>
<p>When <code>overwrite</code> is set to <code>false</code> (default), a window asks for confirmation if the file already exists. In <code>automatic</code> mode, the <a class="el" href="classQGLViewer.html#a4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a> is incremented (if positive) until a non-existing file name is found instead. Otherwise the file is overwritten without confirmation.</p>
<p>The VRender library was written by Cyril Soler (Cyril dot Soler at imag dot fr). If the generated PS or EPS file is not properly displayed, remove the anti-aliasing option in your postscript viewer.</p>
<dl class="section note"><dt>Note</dt><dd>In order to correctly grab the frame buffer, the QGLViewer window is raised in front of other windows by this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a82544567565cfa0b750cb24ac1aa8358"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saveSnapshot </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>, except that it uses <code>fileName</code> instead of <a class="el" href="classQGLViewer.html#a00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a>.</p>
<p>If <code>fileName</code> is empty, opens a file dialog to select the name.</p>
<p>Snapshot settings are set from <a class="el" href="classQGLViewer.html#abbb1add55632dced395e2f1b78ef491c">snapshotFormat()</a> and <a class="el" href="classQGLViewer.html#a50685165e76c57dc87dea3c84b7e5be0">snapshotQuality()</a>.</p>
<p>Asks for confirmation when <code>fileName</code> already exists and <code>overwrite</code> is <code>false</code> (default).</p>
<dl class="section attention"><dt>Attention</dt><dd>If <code>fileName</code> is a char* (as is "myFile.jpg"), it may be casted into a <code>bool</code>, and the other <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> method may be used instead. Pass QString("myFile.jpg") as a parameter to prevent this. </dd></dl>

</div>
</div>
<a class="anchor" id="aaec9168a5f41b3b7fa4211523535ceaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saveStateToFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves in <a class="el" href="classQGLViewer.html#a62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> an XML representation of the QGLViewer state, obtained from <a class="el" href="classQGLViewer.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a>.</p>
<p>Use <a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a> to restore this viewer state.</p>
<p>This method is automatically called when a viewer is closed (using Escape or using the window's upper right <code>x</code> close button). <a class="el" href="classQGLViewer.html#a68737cce3d7301701bca6e4270a5a34e">setStateFileName()</a> to <code>QString::null</code> to prevent this. </p>

</div>
</div>
<a class="anchor" id="a7c5568ae9e5539cf410ef369dba7cec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QFont scaledFont </td>
          <td>(</td>
          <td class="paramtype">const QFont &amp;&#160;</td>
          <td class="paramname"><em>font</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a possibly scaled version of <code>font</code>, used for snapshot rendering.</p>
<p>From a user's point of view, this method simply returns <code>font</code> and can be used transparently.</p>
<p>However when internally rendering a screen snapshot using <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>, it returns a scaled version of the font, so that the size of the rendered text on the snapshot is identical to what is displayed on screen, even if the snapshot uses image tiling to create an image of dimensions different from those of the current window. This scaled version will only be used when <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> calls your <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> method to generate the snapshot.</p>
<p>All your calls to QGLWidget::renderText() function hence should use this method. </p><div class="fragment"><div class="line">renderText(x, y, z, <span class="stringliteral">&quot;My Text&quot;</span>, <a class="code" href="classQGLViewer.html#a7c5568ae9e5539cf410ef369dba7cec5">scaledFont</a>(QFont()));</div>
</div><!-- fragment --><p> will guarantee that this text will be properly displayed on arbitrary sized snapshots.</p>
<p>Note that this method is not needed if you use <a class="el" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText()</a> which already calls it internally. </p>

</div>
</div>
<a class="anchor" id="a5a0503bc22a710f96bfd779eaf538bab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> sceneCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the scene center, defined in world coordinates.</p>
<p>See <a class="el" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius()</a> for details.</p>
<p>Default value is (0,0,0). Simply a wrapper for <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;<a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a>. Set using <a class="el" href="classQGLViewer.html#a6712acd05f9d518d6babfe96e537d06d">setSceneCenter()</a>.</p>
<p>Do not mismatch this value (that only depends on the scene) with the <a class="el" href="classqglviewer_1_1Camera.html#adc85bef2e09f3d874e0de957b107a8fa">qglviewer::Camera::pivotPoint()</a>. </p>

</div>
</div>
<a class="anchor" id="a32b418de3796a253b28c9635b2f4f6fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qreal sceneRadius </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the scene radius.</p>
<p>The entire displayed scene should be included in a sphere of radius <a class="el" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius()</a>, centered on <a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a>.</p>
<p>This approximate value is used by the <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a> to set <a class="el" href="classqglviewer_1_1Camera.html#a41c0dcedcae5b5d5d326f67fc0126ec0">qglviewer::Camera::zNear()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a75932dd1002e31ca5f205c3ada493391">qglviewer::Camera::zFar()</a>. It is also used to <a class="el" href="classQGLViewer.html#ada8dd7d2346ebf46ed1f9822a8418df2">showEntireScene()</a> or to scale the world axis display..</p>
<p>Default value is 1.0. This method is equivalent to <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;<a class="el" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius()</a>. See <a class="el" href="classQGLViewer.html#ad5138140e12f0fdcf7370b9c6d85eedd">setSceneRadius()</a>. </p>

</div>
</div>
<a class="anchor" id="a3b20e4da96e6d8c038a08c7d34d182c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void select </td>
          <td>(</td>
          <td class="paramtype">const QMouseEvent *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple wrapper method: calls <code>select</code>(event-&gt;pos()).</p>
<p>Emits <code>pointSelected(e)</code> which is useful only if you rely on the Qt signal-slot mechanism and you did not overload QGLViewer. If you choose to derive your own viewer class, simply overload <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> (or probably simply <a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a>, see the <a href="../examples/select.html">select example</a>) to implement your selection mechanism.</p>
<p>This method is called when you use the <a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa1697a91b22c2369eb2ba427c2d193329">SELECT</a> mouse binding(s) (default is Shift + left button). Use <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a> to change this. </p>

</div>
</div>
<a class="anchor" id="af2ed82c063635ce439d9c73223e20fd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void select </td>
          <td>(</td>
          <td class="paramtype">const QPoint &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method performs a selection in the scene from pixel coordinates.</p>
<p>It is called when the user clicks on the <a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8fa1697a91b22c2369eb2ba427c2d193329">SELECT</a> <a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">QGLViewer::ClickAction</a> binded button(s) (default is Shift + LeftButton).</p>
<p>This template method successively calls four other methods: </p><div class="fragment"><div class="line"><a class="code" href="classQGLViewer.html#af0a48cc50f194926bad38d4924162116">beginSelection</a>(point);</div>
<div class="line"><a class="code" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames</a>();</div>
<div class="line"><a class="code" href="classQGLViewer.html#a0d164809a99bbe6ff2fc0dee33fe0e91">endSelection</a>(point);</div>
<div class="line"><a class="code" href="classQGLViewer.html#a3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection</a>(point);</div>
</div><!-- fragment --><p>The default implementation of these methods is as follows (see the methods' documentation for more details):</p>
<ul>
<li><a class="el" href="classQGLViewer.html#af0a48cc50f194926bad38d4924162116">beginSelection()</a> sets the <code>GL_SELECT</code> mode with the appropriate picking matrices. A rectangular frustum (of size defined by <a class="el" href="classQGLViewer.html#a16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth()</a> and <a class="el" href="classQGLViewer.html#adb0b15577ca9bcabc99c78601cfce59f">selectRegionHeight()</a>) centered on <code>point</code> is created.</li>
</ul>
<ul>
<li><a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a> is empty and should be overloaded. It draws each selectable object of the scene, enclosed by calls to <code>glPushName()</code> / <code>glPopName()</code> to tag the object with an integer id.</li>
</ul>
<ul>
<li><a class="el" href="classQGLViewer.html#a0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> then restores <code>GL_RENDER</code> mode and analyzes the <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a> to set in <a class="el" href="classQGLViewer.html#a0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> the id of the object that was drawn in the region. If several object are in the region, the closest one in the depth buffer is chosen. If no object has been drawn under cursor, <a class="el" href="classQGLViewer.html#a0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> is set to -1.</li>
</ul>
<ul>
<li><a class="el" href="classQGLViewer.html#a3dc0d3b212e04bcafd63e9c3eb214a6c">postSelection()</a> is empty and can be overloaded for possible signal/display/interface update.</li>
</ul>
<p>See the <code>glSelectBuffer()</code> man page for details on this <code>GL_SELECT</code> mechanism.</p>
<p>This default implementation is quite limited: only the closer object is selected, and only one level of names can be pushed. However, this reveals sufficient in many cases and you usually only have to overload <a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a> to implement a simple object selection process. See the <a href="../examples/select.html">select example</a> for an illustration.</p>
<p>If you need a more complex selection process (such as a point, edge or triangle selection, which is easier with a 2 or 3 levels <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a> heap, and which requires a finer depth sorting to privilege point over edge and edges over triangles), overload the <a class="el" href="classQGLViewer.html#a0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> method. Use <a class="el" href="classQGLViewer.html#a0bfc48a72feefc6c90bd187280853911">setSelectRegionWidth()</a>, <a class="el" href="classQGLViewer.html#ae830757057c41db506410fd3c332d7dd">setSelectRegionHeight()</a> and <a class="el" href="classQGLViewer.html#ae8af6dc4a89202211b764647caf3d1f3">setSelectBufferSize()</a> to tune the select buffer configuration. See the <a href="../examples/multiSelect.html">multiSelect example</a> for an illustration.</p>
<p><code>point</code> is the center pixel (origin in the upper left corner) of the selection region. Use <a class="el" href="classqglviewer_1_1Camera.html#a706d401cffa41e0e30864e59007f005f">qglviewer::Camera::convertClickToLine()</a> to transform these coordinates in a 3D ray if you want to perform an analytical intersection.</p>
<dl class="section attention"><dt>Attention</dt><dd><code>GL_SELECT</code> mode seems to report wrong results when used in conjunction with backface culling. If you encounter problems try to <code>glDisable(GL_CULL_FACE)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a87015f560fd54b358d185482ae82eec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint* selectBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to an array of <code>GLuint</code>.</p>
<p>This buffer is used by the <code>GL_SELECT</code> mode in <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> to perform object selection. The buffer size can be modified using <a class="el" href="classQGLViewer.html#ae8af6dc4a89202211b764647caf3d1f3">setSelectBufferSize()</a>. If you overload <a class="el" href="classQGLViewer.html#a0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a>, you will analyze the content of this buffer. See the <code>glSelectBuffer()</code> man page for details. </p>

</div>
</div>
<a class="anchor" id="a13e131ca92b021fb8946a9af0b0c269d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int selectBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a> size.</p>
<p>See the <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> documentation for details. Use <a class="el" href="classQGLViewer.html#ae8af6dc4a89202211b764647caf3d1f3">setSelectBufferSize()</a> to change this value.</p>
<p>Default value is 4000 (i.e. 1000 objects in selection region, since each object pushes 4 values). This size should be over estimated to prevent a buffer overflow when many objects are drawn under the mouse cursor. </p>

</div>
</div>
<a class="anchor" id="a0015a8bc683c3a1483c5ad638550bdde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int selectedName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name (an integer value) of the entity that was last selected by <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a>. This value is set by <a class="el" href="classQGLViewer.html#a0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a>. See the <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a> documentation for details.</p>
<p>As a convention, this method returns -1 if the <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a> was empty, meaning that no object was selected.</p>
<p>Return value is -1 before the first call to <a class="el" href="classQGLViewer.html#a3b20e4da96e6d8c038a08c7d34d182c6">select()</a>. This value is modified using <a class="el" href="classQGLViewer.html#aeaa1327270d0bcdf991874e7d741afd5">setSelectedName()</a>. </p>

</div>
</div>
<a class="anchor" id="adb0b15577ca9bcabc99c78601cfce59f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int selectRegionHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See the <a class="el" href="classQGLViewer.html#a16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth()</a> documentation. Default value is 3 pixels. </p>

</div>
</div>
<a class="anchor" id="a16ad2d80aa574d32ae8237f56cfd7e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int selectRegionWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the width (in pixels) of a selection frustum, centered on the mouse cursor, that is used to select objects.</p>
<p>The height of the selection frustum is defined by <a class="el" href="classQGLViewer.html#adb0b15577ca9bcabc99c78601cfce59f">selectRegionHeight()</a>.</p>
<p>The objects that will be drawn in this region by <a class="el" href="classQGLViewer.html#a528b238068a87472df8ac3a5b2481c55">drawWithNames()</a> will be recorded in the <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a>. <a class="el" href="classQGLViewer.html#a0d164809a99bbe6ff2fc0dee33fe0e91">endSelection()</a> then analyzes this buffer and <a class="el" href="classQGLViewer.html#aeaa1327270d0bcdf991874e7d741afd5">setSelectedName()</a> to the name of the closest object. See the gluPickMatrix() documentation for details.</p>
<p>The default value is 3, which is adapted to standard applications. A smaller value results in a more precise selection but the user has to be careful for small feature selection.</p>
<p>See the <a href="../examples/multiSelect.html">multiSelect example</a> for an illustration. </p>

</div>
</div>
<a class="anchor" id="afe04d1c918e50f6b4db5f7b6c7b80219"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setAddKeyFrameKeyboardModifiers </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#aad35c97454fee139eb809488ca7a8cb1">addKeyFrameKeyboardModifiers()</a> value. </p>

</div>
</div>
<a class="anchor" id="aa37d4e0afe6a47e8f4f828ed41072176"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setAnimationPeriod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a700d9398d4293d9274766efa8b17917e">animationPeriod()</a>, in milliseconds. </p>

</div>
</div>
<a class="anchor" id="ad95e0ffd255bcc1fb69c9213d8d8b017"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setAutoBufferSwap </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a36faca915c37548a53ab04f297bb5c17">autoBufferSwap()</a> value. </p>

</div>
</div>
<a class="anchor" id="a5be8cff3702c1a130f8a17330737a887"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setAxisIsDrawn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state of <a class="el" href="classQGLViewer.html#a7d38e6f11078e886f7978525def15797">axisIsDrawn()</a>. Emits the <a class="el" href="classQGLViewer.html#a541cdbec67d0c5895cd6c77c01b0f89e">axisIsDrawnChanged()</a> signal. See also <a class="el" href="classQGLViewer.html#acf2ccb8a346c04a5c7da87da0e8e601f">toggleAxisIsDrawn()</a>. </p>

</div>
</div>
<a class="anchor" id="a70d4e21190fdc47edd88f078dd2037cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setBackgroundColor </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a7ddf68dcfb09cc5a991a06d91cb4cc5b">backgroundColor()</a> of the viewer and calls <code><a class="el" href="classQGLViewer.html#a88b363f05e720484cde551d5f798e69b">qglClearColor()</a></code>. See also <a class="el" href="classQGLViewer.html#a7d986b1944dc5a190e509835e7c79eec">setForegroundColor()</a>. </p>

</div>
</div>
<a class="anchor" id="a9c45e1d2c4777de28664d3db952b7585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1Camera.html">qglviewer::Camera</a> *const&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates a new <a class="el" href="classqglviewer_1_1Camera.html" title="A perspective or orthographic camera. ">qglviewer::Camera</a> to the viewer.</p>
<p>You should only use this method when you derive a new class from <a class="el" href="classqglviewer_1_1Camera.html" title="A perspective or orthographic camera. ">qglviewer::Camera</a> and want to use one of its instances instead of the original class.</p>
<p>It you simply want to save and restore Camera positions, use <a class="el" href="classqglviewer_1_1Camera.html#aa7e7ce69cd4d82497dfbc26f991375d4">qglviewer::Camera::addKeyFrameToPath()</a> and <a class="el" href="classqglviewer_1_1Camera.html#a4299db38c4e04020738e39cfa99d91a0">qglviewer::Camera::playPath()</a> instead.</p>
<p>This method silently ignores <code>NULL</code> <code>camera</code> pointers. The calling method is responsible for deleting the previous camera pointer in order to prevent memory leaks if needed.</p>
<p>The <a class="el" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius()</a> and <a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a> of <code>camera</code> are set to the <em>current</em> QGLViewer values.</p>
<p>All the <code>camera</code> <a class="el" href="classqglviewer_1_1Camera.html#ad4acc41f907360dc96eaa219728948b7">qglviewer::Camera::keyFrameInterpolator()</a> <a class="el" href="classqglviewer_1_1KeyFrameInterpolator.html#ab55c2a4f1732b90057fae4b6037399de">qglviewer::KeyFrameInterpolator::interpolated()</a> signals are connected to the viewer update() slot. The connections with the previous viewer's camera are removed. </p>

</div>
</div>
<a class="anchor" id="a521c83b1d745b37331932b4d7b976d41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setCameraIsEdited </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>edit</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts (<code>edit</code> = <code>true</code>, default) or stops (<code>edit=<code>false</code>)</code> the edition of the <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a>.</p>
<p>Current implementation is limited to paths display. Get current state using <a class="el" href="classQGLViewer.html#a1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This method sets the <a class="el" href="classqglviewer_1_1Camera.html#abcfab7ec0ef378eaafe3f0948b91d392">qglviewer::Camera::zClippingCoefficient()</a> to 5.0 when <code>edit</code> is <code>true</code>, so that the Camera paths (see <a class="el" href="classqglviewer_1_1Camera.html#ad4acc41f907360dc96eaa219728948b7">qglviewer::Camera::keyFrameInterpolator()</a>) are not clipped. It restores the previous value when <code>edit</code> is <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d986b1944dc5a190e509835e7c79eec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setForegroundColor </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#aa2f726def3615050a9c816c0ca32171d">foregroundColor()</a> of the viewer, used to draw visual hints. See also <a class="el" href="classQGLViewer.html#a70d4e21190fdc47edd88f078dd2037cb">setBackgroundColor()</a>. </p>

</div>
</div>
<a class="anchor" id="aad24c89e014de3ea16f071c3bc18f4db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setFPSIsDisplayed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>display</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state of <a class="el" href="classQGLViewer.html#a4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a>. Emits the <a class="el" href="classQGLViewer.html#a4b005fb3bda4582ce4ab7aeda6692699">FPSIsDisplayedChanged()</a> signal. See also <a class="el" href="classQGLViewer.html#ab8a88948237894dca2b7b57a67226d66">toggleFPSIsDisplayed()</a>. </p>

</div>
</div>
<a class="anchor" id="a7e021e15180ba348e90c955bdd28b1a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setFullScreen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullScreen</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a129c439f36bb669672148192abc8ffed">isFullScreen()</a> state.</p>
<p>If the QGLViewer is embedded in an other QWidget (see QWidget::topLevelWidget()), this widget is displayed in full screen instead. </p>

</div>
</div>
<a class="anchor" id="ae9dd114195dfdf82e23b5754b7c161de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGridIsDrawn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state of <a class="el" href="classQGLViewer.html#aee18c56a8321a60771b085a5fe798ee7">gridIsDrawn()</a>. Emits the <a class="el" href="classQGLViewer.html#a02d191cc46db491d9807266fe62b6178">gridIsDrawnChanged()</a> signal. See also <a class="el" href="classQGLViewer.html#a8dfaa8be71152ae881b9347235ccc6a1">toggleGridIsDrawn()</a>. </p>

</div>
</div>
<a class="anchor" id="ae33368bc379da582a3d26df18a6df16c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setKeyDescription </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a custom keyboard shortcut description, that will be displayed in the <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window <code>Keyboard</code> tab.</p>
<p>The <code>key</code> definition is given as an <code>int</code> using Qt enumerated values. Set an empty <code>description</code> to remove a shortcut description: </p><div class="fragment"><div class="line"><a class="code" href="classQGLViewer.html#ae33368bc379da582a3d26df18a6df16c">setKeyDescription</a>(Qt::Key_W, <span class="stringliteral">&quot;Toggles wireframe display&quot;</span>);</div>
<div class="line"><a class="code" href="classQGLViewer.html#ae33368bc379da582a3d26df18a6df16c">setKeyDescription</a>(Qt::CTRL+Qt::Key_L, <span class="stringliteral">&quot;Loads a new scene&quot;</span>);</div>
<div class="line"><span class="comment">// Removes a description</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#ae33368bc379da582a3d26df18a6df16c">setKeyDescription</a>(Qt::CTRL+Qt::Key_C, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse example</a> for illustration and the <a href="../keyboard.html">keyboard page</a> for details. </p>

</div>
</div>
<a class="anchor" id="ac6964ec1ebb2f42464313e0c43e767a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setManipulatedFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1ManipulatedFrame.html">qglviewer::ManipulatedFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the viewer's <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>.</p>
<p>Several objects can be manipulated simultaneously, as is done the <a href="../examples/multiSelect.html">multiSelect example</a>.</p>
<p>Defining the <em>own</em> viewer's <a class="el" href="classQGLViewer.html#a27a9e97573822d296b48e1c408b74042">camera()</a>-&gt;frame() as the <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a> is possible and will result in a classical camera manipulation. See the <a href="../examples/luxo.html">luxo example</a> for an illustration.</p>
<p>Note that a <a class="el" href="classqglviewer_1_1ManipulatedCameraFrame.html" title="The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific mouse bindings...">qglviewer::ManipulatedCameraFrame</a> can be set as the <a class="el" href="classQGLViewer.html#aba8c9c519574192fb7197bdbad8049db">manipulatedFrame()</a>: it is possible to manipulate the camera of a first viewer in a second viewer. </p>

</div>
</div>
<a class="anchor" id="a98e3c0b956c3fea7dc804e7a7a7dd295"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBinding </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withConstraint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a MouseAction binding.</p>
<p>Same as calling <a class="el" href="classQGLViewer.html#a85a2e51796cd902ecc2bdc9ae143e4d5">setMouseBinding(Qt::Key, Qt::KeyboardModifiers, Qt::MouseButton, MouseHandler, MouseAction, bool)</a>, with a key value of Qt::Key(0) (i.e. no regular extra key needs to be pressed to perform this action). </p>

</div>
</div>
<a class="anchor" id="af60ec98df1af2309ef1d16644e9791ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBinding </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleClick</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons&#160;</td>
          <td class="paramname"><em>buttonsBefore</em> = <code>Qt::NoButton</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a ClickAction binding.</p>
<p>Same as calling <a class="el" href="classQGLViewer.html#a837a7cd6b3fa87bff0f1ae85f79fc7ce">setMouseBinding(Qt::Key, Qt::KeyboardModifiers, Qt::MouseButton, ClickAction, bool, Qt::MouseButtons)</a>, with a key value of Qt::Key(0) (i.e. no regular key needs to be pressed to activate this action). </p>

</div>
</div>
<a class="anchor" id="a85a2e51796cd902ecc2bdc9ae143e4d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBinding </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withConstraint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates a MouseAction to any mouse <code>button</code>, while keyboard <code>modifiers</code> and <code>key</code> are pressed. The receiver of the mouse events is a MouseHandler (<a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325dada31f516cdf218b68b790fb31e8a6956">CAMERA</a> or <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325da200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>).</p>
<p>The parameters should read: when the mouse <code>button</code> is pressed, while the keyboard <code>modifiers</code> and <code>key</code> are down, activate <code>action</code> on <code>handler</code>. Use Qt::NoModifier to indicate that no modifier key is needed, and a <code>key</code> value of 0 if no regular key has to be pressed (or simply use <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding(Qt::KeyboardModifiers, Qt::MouseButton, MouseHandler, MouseAction, bool)</a>).</p>
<p>Use the '|' operator to combine modifiers: </p><div class="fragment"><div class="line"><span class="comment">// The R key combined with the Left mouse button rotates the camera in the screen plane.</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding</a>(Qt::Key_R, Qt::NoModifier, Qt::LeftButton, <a class="code" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325dada31f516cdf218b68b790fb31e8a6956">CAMERA</a>, <a class="code" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a410b0fa7f49e7eedd6d739db37c67209">SCREEN_ROTATE</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Alt + Shift and Left button rotates the manipulatedFrame().</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding</a>(Qt::AltModifier | Qt::ShiftModifier, Qt::LeftButton, <a class="code" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325da200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>, <a class="code" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3dcfe0046eb5876e287dbf0914819b16">ROTATE</a>);</div>
</div><!-- fragment --><p>If <code>withConstraint</code> is <code>true</code> (default), the possible <a class="el" href="classqglviewer_1_1Frame.html#a0974dfe336ed84a20adb8c6cdf8dedd9">qglviewer::Frame::constraint()</a> of the associated Frame will be enforced during motion.</p>
<p>The list of all possible MouseAction, some binding examples and default bindings are provided in the <a href="../mouse.html">mouse page</a>.</p>
<p>See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for an illustration.</p>
<p>If no mouse button is specified, the binding is ignored. If an action was previously associated with this keyboard and button combination, it is silently overwritten (call <a class="el" href="classQGLViewer.html#ab689056381e744de41ccc27383294692">mouseAction()</a> before to check).</p>
<p>To remove a specific mouse binding, use <code>NO_MOUSE_ACTION</code> as the <code>action</code>.</p>
<p>See also setMouseBinding(Qt::KeyboardModifiers, Qt::MouseButtons, ClickAction, bool, int), <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a> and <a class="el" href="classQGLViewer.html#a70012fbf36d43b3f618bd339c123d8b7">clearMouseBindings()</a>. </p>

</div>
</div>
<a class="anchor" id="a837a7cd6b3fa87bff0f1ae85f79fc7ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBinding </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a85fe75121d351785616b75b2c5661d8f">ClickAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleClick</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons&#160;</td>
          <td class="paramname"><em>buttonsBefore</em> = <code>Qt::NoButton</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates a ClickAction to a button and keyboard key and modifier(s) combination.</p>
<p>The parameters should read: when <code>button</code> is pressed, while the <code>modifiers</code> and <code>key</code> keys are down, and possibly as a <code>doubleClick</code>, then perform <code>action</code>. Use Qt::NoModifier to indicate that no modifier key is needed, and a <code>key</code> value of 0 if no regular key has to be pressed (or simply use <a class="el" href="classQGLViewer.html#af60ec98df1af2309ef1d16644e9791ef">setMouseBinding(Qt::KeyboardModifiers, Qt::MouseButton, ClickAction, bool, Qt::MouseButtons)</a>).</p>
<p>If <code>buttonsBefore</code> is specified (valid only when <code>doubleClick</code> is <code>true</code>), then this (or these) other mouse button(s) has (have) to be pressed <em>before</em> the double click occurs in order to execute <code>action</code>.</p>
<p>The list of all possible ClickAction, some binding examples and default bindings are listed in the <a href="../mouse.html">mouse page</a>. See also the <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a> documentation.</p>
<p>See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse example</a> for an illustration.</p>
<p>The binding is ignored if Qt::NoButton is specified as <code>buttons</code>.</p>
<p>See also setMouseBinding(Qt::KeyboardModifiers, Qt::MouseButtons, MouseHandler, MouseAction, bool), <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a> and <a class="el" href="classQGLViewer.html#a70012fbf36d43b3f618bd339c123d8b7">clearMouseBindings()</a>. </p>

</div>
</div>
<a class="anchor" id="ae6952d2191d9e47e295fb53248d47702"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBindingDescription </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleClick</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons&#160;</td>
          <td class="paramname"><em>buttonsBefore</em> = <code>Qt::NoButton</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a custom mouse binding description, displayed in the <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window's Mouse tab.</p>
<p>Same as calling <a class="el" href="classQGLViewer.html#a5abc54d8039991ecc1f880fa0c0c4d2d">setMouseBindingDescription(Qt::Key, Qt::KeyboardModifiers, Qt::MouseButton, QString, bool, Qt::MouseButtons)</a>, with a key value of Qt::Key(0) (i.e. binding description when no regular key needs to be pressed). </p>

</div>
</div>
<a class="anchor" id="a5abc54d8039991ecc1f880fa0c0c4d2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseBindingDescription </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButton&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleClick</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::MouseButtons&#160;</td>
          <td class="paramname"><em>buttonsBefore</em> = <code>Qt::NoButton</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a custom mouse binding description, displayed in the <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window's Mouse tab.</p>
<p><code>modifiers</code> is a combination of Qt::KeyboardModifiers (<code>Qt::ControlModifier</code>, <code>Qt::AltModifier</code>, <code>Qt::ShiftModifier</code>, <code>Qt::MetaModifier</code>). Possibly combined using the <code>"|"</code> operator.</p>
<p><code>button</code> is one of the Qt::MouseButtons (<code>Qt::LeftButton</code>, <code>Qt::MidButton</code>, <code>Qt::RightButton</code>...).</p>
<p><code>doubleClick</code> indicates whether or not the user has to double click this button to perform the described action. <code>buttonsBefore</code> lists the buttons that need to be pressed before the double click.</p>
<p>Set an empty <code>description</code> to <em>remove</em> a mouse binding description.</p>
<div class="fragment"><div class="line"><span class="comment">// The R key combined with the Left mouse button rotates the camera in the screen plane.</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#ae6952d2191d9e47e295fb53248d47702">setMouseBindingDescription</a>(Qt::Key_R, Qt::NoModifier, Qt::LeftButton, <span class="stringliteral">&quot;Rotates camera in screen plane&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// A left button double click toggles full screen</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#ae6952d2191d9e47e295fb53248d47702">setMouseBindingDescription</a>(Qt::NoModifier, Qt::LeftButton, <span class="stringliteral">&quot;Toggles full screen mode&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Removes the description of Ctrl+Right button</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#ae6952d2191d9e47e295fb53248d47702">setMouseBindingDescription</a>(Qt::ControlModifier, Qt::RightButton, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>Overload <a class="el" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> and friends to implement your custom mouse behavior (see the <a class="el" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a> documentation for an example). See the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse example</a> for an illustration.</p>
<p>Use <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a> and <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a> to change the standard mouse action bindings. </p>

</div>
</div>
<a class="anchor" id="a993285ef8a16ccbdc5d57a1264212712"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseGrabber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *&#160;</td>
          <td class="paramname"><em>mouseGrabber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Directly defines the <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a>.</p>
<p>You should not call this method directly as it bypasses the <a class="el" href="classqglviewer_1_1MouseGrabber.html#a6110636d4e031373ecebd42c6ea838ea">qglviewer::MouseGrabber::checkIfGrabsMouse()</a> test performed by <a class="el" href="classQGLViewer.html#a88e672693c2cfdbaf9af942a58a8e1dd">mouseMoveEvent()</a>.</p>
<p>If the MouseGrabber is disabled (see <a class="el" href="classQGLViewer.html#a5fe9b0a1fcd39a5cb132ffdc86f2574f">mouseGrabberIsEnabled()</a>), this method silently does nothing. </p>

</div>
</div>
<a class="anchor" id="a3f0b956f948f469c095ff3c2c1b73494"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMouseGrabberIsEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1MouseGrabber.html">qglviewer::MouseGrabber</a> *const&#160;</td>
          <td class="paramname"><em>mouseGrabber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a5fe9b0a1fcd39a5cb132ffdc86f2574f">mouseGrabberIsEnabled()</a> state. </p>

</div>
</div>
<a class="anchor" id="acf0a4ee197fe91b8c07dd74cad1aafaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setMouseTracking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a47c0968a61bcd23c491817631e4ec953">hasMouseTracking()</a> value. </p>

</div>
</div>
<a class="anchor" id="a5542c73a9c2c62be3cde9144d950fd13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setPathKey </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#aab5d27e632d4a2116e602bc67005b0e5">pathKey()</a> associated with the camera Key Frame path <code>index</code>.</p>
<p>Several keys can be binded to the same <code>index</code>. Use a negated <code>key</code> value to delete the binding (the <code>index</code> value is then ignored): </p><div class="fragment"><div class="line"><span class="comment">// Press &#39;space&#39; to play/pause/add/delete camera path of index 0.</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a5542c73a9c2c62be3cde9144d950fd13">setPathKey</a>(Qt::Key_Space, 0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Remove this binding</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a5542c73a9c2c62be3cde9144d950fd13">setPathKey</a>(-Qt::Key_Space);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab8e16934baadfe8db4f68dedc98075a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setPlayPathKeyboardModifiers </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a53cd07399d3ed7b88cdf69d9cd17488d">playPathKeyboardModifiers()</a> value. </p>

</div>
</div>
<a class="anchor" id="aa8339148d876e633c27e5df826f06c9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSceneBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenient way to call <a class="el" href="classQGLViewer.html#a6712acd05f9d518d6babfe96e537d06d">setSceneCenter()</a> and <a class="el" href="classQGLViewer.html#ad5138140e12f0fdcf7370b9c6d85eedd">setSceneRadius()</a> from a (world axis aligned) bounding box of the scene. </p><pre class="fragment">This is equivalent to:
</pre> <div class="fragment"><div class="line"><a class="code" href="classQGLViewer.html#a6712acd05f9d518d6babfe96e537d06d">setSceneCenter</a>((min+max) / 2.0);</div>
<div class="line"><a class="code" href="classQGLViewer.html#ad5138140e12f0fdcf7370b9c6d85eedd">setSceneRadius</a>((max-min).norm() / 2.0);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6712acd05f9d518d6babfe96e537d06d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setSceneCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqglviewer_1_1Vec.html">qglviewer::Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a5a0503bc22a710f96bfd779eaf538bab">sceneCenter()</a>, defined in world coordinates. </p><pre class="fragment">\attention The qglviewer::Camera::pivotPoint() is set to the sceneCenter() value by this
method.  </pre> 
</div>
</div>
<a class="anchor" id="ad5138140e12f0fdcf7370b9c6d85eedd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setSceneRadius </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a32b418de3796a253b28c9635b2f4f6fb">sceneRadius()</a>. </p><pre class="fragment">The camera() qglviewer::Camera::flySpeed() is set to 1% of this value by this method. Simple
wrapper around camera()-&gt;setSceneRadius().  </pre> 
</div>
</div>
<a class="anchor" id="ae8af6dc4a89202211b764647caf3d1f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSelectBufferSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a13e131ca92b021fb8946a9af0b0c269d">selectBufferSize()</a>.</p>
<p>The previous <a class="el" href="classQGLViewer.html#a87015f560fd54b358d185482ae82eec3">selectBuffer()</a> is deleted and a new one is created. </p>

</div>
</div>
<a class="anchor" id="aeaa1327270d0bcdf991874e7d741afd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSelectedName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <a class="el" href="classQGLViewer.html#a0015a8bc683c3a1483c5ad638550bdde">selectedName()</a> value. </p><pre class="fragment">Used in endSelection() during a selection. You should only call this method if you overload the
endSelection() method.  </pre> 
</div>
</div>
<a class="anchor" id="ae830757057c41db506410fd3c332d7dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSelectRegionHeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#adb0b15577ca9bcabc99c78601cfce59f">selectRegionHeight()</a>. </p>

</div>
</div>
<a class="anchor" id="a0bfc48a72feefc6c90bd187280853911"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSelectRegionWidth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a16ad2d80aa574d32ae8237f56cfd7e06">selectRegionWidth()</a>. </p>

</div>
</div>
<a class="anchor" id="a34d76d224c67a0fdae03f0d921bf3330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setShortcut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines the <a class="el" href="classQGLViewer.html#af8f502daf9ffa61c8904f891c843e994">shortcut()</a> that triggers a given <a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">QGLViewer::KeyboardAction</a>.</p>
<p>Here are some examples: </p><div class="fragment"><div class="line"><span class="comment">// Press &#39;Q&#39; to exit application</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut</a>(<a class="code" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a7ff2639b181c08e5d9196a0303a72cd1">EXIT_VIEWER</a>, Qt::Key_Q);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Alt+M toggles camera mode</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut</a>(<a class="code" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a91b759170cb0389695a3c219a9a69073">CAMERA_MODE</a>, Qt::ALT + Qt::Key_M);</div>
<div class="line"></div>
<div class="line"><span class="comment">// The DISPLAY_FPS action is disabled</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut</a>(<a class="code" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1a7522d8401eb437769071ba3b1562ca97">DISPLAY_FPS</a>, 0);</div>
</div><!-- fragment --><p>Only one shortcut can be assigned to a given <a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">QGLViewer::KeyboardAction</a> (new bindings replace previous ones). If several KeyboardAction are binded to the same shortcut, only one of them is active. </p>

</div>
</div>
<a class="anchor" id="afeb307bbd1a56cdfb3749f699d4af03c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSnapshotCounter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>counter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a4de825bb96eba2c5f6a55facb9dc4cef">snapshotCounter()</a>. </p>

</div>
</div>
<a class="anchor" id="aa15be68d137eca013942eae69e40e0ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSnapshotFileName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="classQGLViewer.html#a00f2094711c7349fe1f74b6fc0b5530f">snapshotFileName()</a>. </p>

</div>
</div>
<a class="anchor" id="a82043998256d08163f79ceee83278e14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSnapshotFormat </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#abbb1add55632dced395e2f1b78ef491c">snapshotFormat()</a>. </p>

</div>
</div>
<a class="anchor" id="ab64b04b76b1f35ee1b3f07fa747dc9a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSnapshotQuality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="classQGLViewer.html#a50685165e76c57dc87dea3c84b7e5be0">snapshotQuality()</a>. </p>

</div>
</div>
<a class="anchor" id="a68737cce3d7301701bca6e4270a5a34e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStateFileName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines the <a class="el" href="classQGLViewer.html#a62b572fd9b9afecb2ac055a24ca9dfa0">stateFileName()</a> used by <a class="el" href="classQGLViewer.html#aaec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a> and <a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a>. </p><pre class="fragment">The file name can have an optional prefix directory (no prefix meaning current directory). If the
directory does not exist, it will be created by saveStateToFile().
</pre><div class="fragment"><div class="line"><span class="comment">// Name depends on the displayed 3D model. Saved in current directory.</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a68737cce3d7301701bca6e4270a5a34e">setStateFileName</a>(3DModelName() + <span class="stringliteral">&quot;.xml&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Files are stored in a dedicated directory under user&#39;s home directory.</span></div>
<div class="line"><a class="code" href="classQGLViewer.html#a68737cce3d7301701bca6e4270a5a34e">setStateFileName</a>(QDir::homeDirPath + <span class="stringliteral">&quot;/.config/myApp.xml&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afe362ba5c3851a93f23fb833b2479f08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStereoDisplay </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stereo</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state of <a class="el" href="classQGLViewer.html#a2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a>. See also <a class="el" href="classQGLViewer.html#a4e0ebf98eacbcbad3b094e26d9e35886">toggleStereoDisplay()</a>.</p>
<p>First checks that the display is able to handle stereovision using QGLWidget::format(). Opens a warning message box in case of failure. Emits the <a class="el" href="classQGLViewer.html#a9d7df8ab7c351e32da3c72b19c4585c0">stereoChanged()</a> signal otherwise. </p>

</div>
</div>
<a class="anchor" id="a73d76caa402acd217e504d0bcd13e421"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTextIsEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state of <a class="el" href="classQGLViewer.html#a87896d67f84ddb458e1e5ab326db2631">textIsEnabled()</a>. Emits the <a class="el" href="classQGLViewer.html#ac0b30c0de291a24af638e8c1d6171943">textIsEnabledChanged()</a> signal. See also <a class="el" href="classQGLViewer.html#ab92b2b41db85e4347675b0bc453366d7">toggleTextIsEnabled()</a>. </p>

</div>
</div>
<a class="anchor" id="a277f432be05de69ae2df05eac8951ad2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setWheelBinding </td>
          <td>(</td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withConstraint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines a mouse wheel binding.</p>
<p>Same as calling <a class="el" href="classQGLViewer.html#ac418dcff525e4236ebd4e8324fb725b1">setWheelBinding(Qt::Key, Qt::KeyboardModifiers, MouseHandler, MouseAction, bool)</a>, with a key value of Qt::Key(0) (i.e. no regular key needs to be pressed to activate this action). </p>

</div>
</div>
<a class="anchor" id="ac418dcff525e4236ebd4e8324fb725b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setWheelBinding </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325d">MouseHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">MouseAction</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withConstraint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates a MouseAction and a MouseHandler to a mouse wheel event.</p>
<p>This method is very similar to <a class="el" href="classQGLViewer.html#a98e3c0b956c3fea7dc804e7a7a7dd295">setMouseBinding()</a>, but specific to the wheel.</p>
<p>In the current implementation only <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a604adefe799fe794cab6b76ed1108201">ZOOM</a> can be associated with <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325da200c1bcf1eaa8635daa3cbb5fdd2ebb6">FRAME</a>, while <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325dada31f516cdf218b68b790fb31e8a6956">CAMERA</a> can receive <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a604adefe799fe794cab6b76ed1108201">ZOOM</a> and <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a99906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a>.</p>
<p>The difference between <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a604adefe799fe794cab6b76ed1108201">ZOOM</a> and <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a99906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a> is that <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a604adefe799fe794cab6b76ed1108201">ZOOM</a> speed depends on the distance to the object, while <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a99906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a> moves at a constant speed defined by <a class="el" href="classqglviewer_1_1Camera.html#a906c1998f29453838417d8ce80cf3ebe">qglviewer::Camera::flySpeed()</a>. </p>

</div>
</div>
<a class="anchor" id="af8f502daf9ffa61c8904f891c843e994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int shortcut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">KeyboardAction</a>&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the keyboard shortcut associated to a given <a class="el" href="classQGLViewer.html#a7a90ec0b49f9586addb5eed9026077c1">QGLViewer::KeyboardAction</a>.</p>
<p>Result is an <code>unsigned</code> <code>int</code> defined using Qt enumerated values, as in <code>Qt::Key_Q</code> or <code>Qt::CTRL</code> + Qt::Key_X. Use Qt::MODIFIER_MASK to separate the key from the state keys. Returns <code>0</code> if the KeyboardAction is disabled (not binded). Set using <a class="el" href="classQGLViewer.html#a34d76d224c67a0fdae03f0d921bf3330">setShortcut()</a>.</p>
<p>If you want to define keyboard shortcuts for custom actions (say, open a scene file), overload <a class="el" href="classQGLViewer.html#a2cc4c898ca007c7cc0ebb7791aa3e5b3">keyPressEvent()</a> and then <a class="el" href="classQGLViewer.html#ae33368bc379da582a3d26df18a6df16c">setKeyDescription()</a>.</p>
<p>These shortcuts and their descriptions are automatically included in the <a class="el" href="classQGLViewer.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> window <code>Keyboard</code> tab.</p>
<p>See the <a href="../keyboard.html">keyboard page</a> for details and default values and the <a href="../examples/keyboardAndMouse.html">keyboardAndMouse</a> example for a practical illustration. </p>

</div>
</div>
<a class="anchor" id="ada8dd7d2346ebf46ed1f9822a8418df2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void showEntireScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves the camera so that the entire scene is visible. </p><pre class="fragment">Simple wrapper around qglviewer::Camera::showEntireScene().  </pre> 
</div>
</div>
<a class="anchor" id="ad8288a17cf54658f1ce1c0db9e97dc8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QSize sizeHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the recommended size for the QGLViewer. Default value is 600x400 pixels. </p>

</div>
</div>
<a class="anchor" id="a4de825bb96eba2c5f6a55facb9dc4cef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snapshotCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of the counter used to name snapshots in <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> when <code>automatic</code> is <code>true</code>.</p>
<p>Set using <a class="el" href="classQGLViewer.html#afeb307bbd1a56cdfb3749f699d4af03c">setSnapshotCounter()</a>. Default value is 0, and it is incremented after each <code>automatic</code> snapshot. See <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> for details. </p>

</div>
</div>
<a class="anchor" id="a00f2094711c7349fe1f74b6fc0b5530f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QString&amp; snapshotFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the snapshot file name used by <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>.</p>
<p>This value is used in <code>automatic</code> mode (see <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>). A dialog is otherwise popped-up to set it.</p>
<p>You can also directly provide a file name using <a class="el" href="classQGLViewer.html#a82544567565cfa0b750cb24ac1aa8358">saveSnapshot(const QString&amp;, bool)</a>.</p>
<p>If the file name is relative, the current working directory at the moment of the method call is used. Set using <a class="el" href="classQGLViewer.html#aa15be68d137eca013942eae69e40e0ee">setSnapshotFileName()</a>. </p>

</div>
</div>
<a class="anchor" id="abbb1add55632dced395e2f1b78ef491c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QString&amp; snapshotFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the snapshot file format used by <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>.</p>
<p>This value is used when <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> is passed the <code>automatic</code> flag. It is defined using a saveAs pop-up dialog otherwise.</p>
<p>The available formats are those handled by Qt. Classical values are <code>"JPEG"</code>, <code>"PNG"</code>, <code>"PPM"</code>, <code>"BMP"</code>. Use the following code to get the actual list: </p><div class="fragment"><div class="line">QList&lt;QByteArray&gt; formatList = QImageReader::supportedImageFormats();</div>
<div class="line"><span class="comment">// or with Qt version 2 or 3:</span></div>
<div class="line">QStringList formatList = QImage::outputFormatList();</div>
</div><!-- fragment --><p>If the library was compiled with the vectorial rendering option (default), three additional vectorial formats are available: <code>"EPS"</code>, <code>"PS"</code> and <code>"XFIG"</code>. <code>"SVG"</code> and <code>"PDF"</code> formats should soon be available. The <a href="http://artis.imag.fr/Software/VRender">VRender library</a> was created by Cyril Soler.</p>
<p>Note that the VRender library has some limitations: vertex shader effects are not reproduced and <code>PASS_THROUGH</code> tokens are not handled so one can not change point and line size in the middle of a drawing.</p>
<p>Default value is the first supported among "JPEG, PNG, EPS, PS, PPM, BMP", in that order.</p>
<p>This value is set using <a class="el" href="classQGLViewer.html#a82043998256d08163f79ceee83278e14">setSnapshotFormat()</a> or with <a class="el" href="classQGLViewer.html#ac9c409fd034bc5ab42aacfa4c23fe55c">openSnapshotFormatDialog()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>No verification is performed on the provided format validity. The next call to <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a> may fail if the format string is not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="a50685165e76c57dc87dea3c84b7e5be0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snapshotQuality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the image quality of the snapshots produced with <a class="el" href="classQGLViewer.html#a1cf2ffb973b096b249dc7e90327a2a8e">saveSnapshot()</a>.</p>
<p>Values must be in the range -1..100. Use 0 for lowest quality and 100 for highest quality (and larger files). -1 means use Qt default quality. Default value is 95.</p>
<p>Set using <a class="el" href="classQGLViewer.html#ab64b04b76b1f35ee1b3f07fa747dc9a0">setSnapshotQuality()</a>. See also the QImage::save() documentation.</p>
<dl class="section note"><dt>Note</dt><dd>This value has no impact on the images produced in vectorial format. </dd></dl>

</div>
</div>
<a class="anchor" id="a6054c5da7cfd763db7c0b214026a50ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snapshotToClipboard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes a snapshot of the current display and pastes it to the clipboard.</p>
<p>This action is activated by the KeyboardAction::SNAPSHOT_TO_CLIPBOARD enum, binded to <code>Ctrl+C</code> by default. </p>

</div>
</div>
<a class="anchor" id="ad5344a5f702678f309fafa0c699b2cf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void startAnimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the animation loop. See <a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>. </p>

</div>
</div>
<a class="anchor" id="a5825ac26bdef13ae5ddd021e318aaf15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void startScreenCoordinatesSystem </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upward</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modify the projection matrix so that drawing can be done directly with 2D screen coordinates.</p>
<p>Once called, the <code>x</code> and <code>y</code> coordinates passed to <code>glVertex</code> are expressed in pixels screen coordinates. The origin (0,0) is in the upper left corner of the widget by default. This follows the Qt standards, so that you can directly use the <code>pos()</code> provided by for instance <code>QMouseEvent</code>. Set <code>upward</code> to <code>true</code> to place the origin in the <em>lower</em> left corner, thus following the OpenGL and mathematical standards. It is always possible to switch between the two representations using <code>newY</code> = <a class="el" href="classQGLViewer.html#ae26bcfe2f33f5873dbdfb6948cf1f59f">height()</a> - <code>y</code>.</p>
<p>You need to call <a class="el" href="classQGLViewer.html#a9cff22af974391604bff7f91df789138">stopScreenCoordinatesSystem()</a> at the end of the drawing block to restore the previous camera matrix.</p>
<p>In practice, this method should be used in <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. It sets an appropriate orthographic projection matrix and then sets <code>glMatrixMode</code> to <code>GL_MODELVIEW</code>.</p>
<p>See the <a href="../examples/screenCoordSystem.html">screenCoordSystem</a>, <a href="../examples/multiSelect.html">multiSelect</a> and <a href="../examples/contribs.html#backgroundImage">backgroundImage</a> examples for an illustration.</p>
<p>You may want to disable <code>GL_LIGHTING</code>, to enable <code>GL_LINE_SMOOTH</code> or <code>GL_BLEND</code> to draw when this method is used.</p>
<p>If you want to link 2D drawings to 3D objects, use <a class="el" href="classqglviewer_1_1Camera.html#ac4dc649d17bd2ae8664a7f4fdd50360f">qglviewer::Camera::projectedCoordinatesOf()</a> to compute the 2D projection on screen of a 3D point (see the <a href="../examples/screenCoordSystem.html">screenCoordSystem</a> example). See also <a class="el" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText()</a>.</p>
<p>In this mode, you should use z values that are in the [0.0, 1.0[ range (0.0 corresponding to the near clipping plane and 1.0 being just beyond the far clipping plane). This interval matches the values that can be read from the z-buffer. Note that if you use the convenient <code>glVertex2i()</code> to provide coordinates, the implicit 0.0 z coordinate will make your drawings appear <em>on</em> <em>top</em> of the rest of the scene. </p>

</div>
</div>
<a class="anchor" id="a62b572fd9b9afecb2ac055a24ca9dfa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString stateFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the state file name. Default value is <code></code>.qglviewer.xml.</p>
<p>This is the name of the XML file where <a class="el" href="classQGLViewer.html#aaec9168a5f41b3b7fa4211523535ceaa">saveStateToFile()</a> saves the viewer state (camera state, widget geometry, display flags... see <a class="el" href="classQGLViewer.html#a48e0e2dd26cd96418c8b889ceabe80f6">domElement()</a>) on exit. Use <a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a> to restore this state later (usually in your <a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">init()</a> method).</p>
<p>Setting this value to <code>QString::null</code> will disable the automatic state file saving that normally occurs on exit.</p>
<p>If more than one viewer are created by the application, this function will return a numbered file name (as in ".qglviewer1.xml", ".qglviewer2.xml"... using <a class="el" href="classQGLViewer.html#a9570ddcbaab08bce6f121e69db4fb903">QGLViewer::QGLViewerIndex()</a>) for extra viewers. Each viewer will then read back its own information in <a class="el" href="classQGLViewer.html#a212f6b7b669463c2151688f629d72a81">restoreStateFromFile()</a>, provided that the viewers are created in the same order, which is usually the case. </p>

</div>
</div>
<a class="anchor" id="a9d7df8ab7c351e32da3c72b19c4585c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stereoChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever <a class="el" href="classQGLViewer.html#a2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a> changes value. </p>

</div>
</div>
<a class="anchor" id="a84c1367b486680bcf22987540e217cfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stopAnimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops animation. See <a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>. </p>

</div>
</div>
<a class="anchor" id="a9cff22af974391604bff7f91df789138"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stopScreenCoordinatesSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops the pixel coordinate drawing block started by <a class="el" href="classQGLViewer.html#a5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem()</a>.</p>
<p>The <code>GL_MODELVIEW</code> and <code>GL_PROJECTION</code> matrices modified in <a class="el" href="classQGLViewer.html#a5825ac26bdef13ae5ddd021e318aaf15">startScreenCoordinatesSystem()</a> are restored. <code>glMatrixMode</code> is set to <code>GL_MODELVIEW</code>. </p>

</div>
</div>
<a class="anchor" id="a87896d67f84ddb458e1e5ab326db2631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool textIsEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if text display (see <a class="el" href="classQGLViewer.html#ad604ec747b161c869877fcb647a3c775">drawText()</a>) is enabled.</p>
<p>Set by <a class="el" href="classQGLViewer.html#a73d76caa402acd217e504d0bcd13e421">setTextIsEnabled()</a> or <a class="el" href="classQGLViewer.html#ab92b2b41db85e4347675b0bc453366d7">toggleTextIsEnabled()</a>. This feature conveniently removes all the possibly displayed text, cleaning display. Default value is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="ac0b30c0de291a24af638e8c1d6171943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void textIsEnabledChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever <a class="el" href="classQGLViewer.html#a87896d67f84ddb458e1e5ab326db2631">textIsEnabled()</a> changes value. </p>

</div>
</div>
<a class="anchor" id="acd355cb527aec563bbefc75edc9deffd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void timerEvent </td>
          <td>(</td>
          <td class="paramtype">QTimerEvent *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloading of the <code>QObject</code> method.</p>
<p>If <a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>, calls <a class="el" href="classQGLViewer.html#a64465ac69c7fe9f4f8519a57501c76c2">animate()</a> and <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a>. </p>

</div>
</div>
<a class="anchor" id="a67be4f5d4065852e7f46a2fc6197c070"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleAnimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classQGLViewer.html#ad5344a5f702678f309fafa0c699b2cf3">startAnimation()</a> or <a class="el" href="classQGLViewer.html#a84c1367b486680bcf22987540e217cfb">stopAnimation()</a>, depending on <a class="el" href="classQGLViewer.html#ad865668850fb0aa249e79f21d2e9d40e">animationIsStarted()</a>. </p>

</div>
</div>
<a class="anchor" id="acf2ccb8a346c04a5c7da87da0e8e601f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleAxisIsDrawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Toggles the state of <a class="el" href="classQGLViewer.html#a7d38e6f11078e886f7978525def15797">axisIsDrawn()</a>. See also <a class="el" href="classQGLViewer.html#a5be8cff3702c1a130f8a17330737a887">setAxisIsDrawn()</a>. </p>

</div>
</div>
<a class="anchor" id="a3a53b30eacfccf0825b808977d634936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleCameraIsEdited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Toggles the state of <a class="el" href="classQGLViewer.html#a1bf2817fb27f0ad326e3db75aeb46af7">cameraIsEdited()</a>. See also <a class="el" href="classQGLViewer.html#a521c83b1d745b37331932b4d7b976d41">setCameraIsEdited()</a>. </p>

</div>
</div>
<a class="anchor" id="a17ea00dd30fb78086cf7e22bc2f10695"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleCameraMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps between two predefined camera mouse bindings.</p>
<p>The first mode makes the camera observe the scene while revolving around the <a class="el" href="classqglviewer_1_1Camera.html#adc85bef2e09f3d874e0de957b107a8fa">qglviewer::Camera::pivotPoint()</a>. The second mode is designed for walkthrough applications and simulates a flying camera.</p>
<p>Practically, the three mouse buttons are respectively binded to: </p><ul>
<li>In rotate mode: <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3dcfe0046eb5876e287dbf0914819b16">ROTATE</a>, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a604adefe799fe794cab6b76ed1108201">ZOOM</a>, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875abc6501410409b0638909b580970b35f7">TRANSLATE</a>. </li>
<li>In fly mode: <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a99906f0ddded6cfdab57271cd33e308c">MOVE_FORWARD</a>, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a21fa52d8ef1574dce79cab9ddbb6cd73">LOOK_AROUND</a>, <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875ab3313fc5887b62fd14b36f1d67903e08">MOVE_BACKWARD</a>.</li>
</ul>
<p>The current mode is determined by checking if a mouse button is binded to <a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875a3dcfe0046eb5876e287dbf0914819b16">ROTATE</a> for the <a class="el" href="classQGLViewer.html#a5b90ab220b7700ca28db5ecf3217325dada31f516cdf218b68b790fb31e8a6956">CAMERA</a>. The state key that was previously used to move the camera is preserved. </p>

</div>
</div>
<a class="anchor" id="ab8a88948237894dca2b7b57a67226d66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleFPSIsDisplayed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Toggles the state of <a class="el" href="classQGLViewer.html#a4b8985b86aca5584d9869c8ac868984a">FPSIsDisplayed()</a>. See also <a class="el" href="classQGLViewer.html#aad24c89e014de3ea16f071c3bc18f4db">setFPSIsDisplayed()</a>. </p>

</div>
</div>
<a class="anchor" id="aa5b47397e4ad7c2bb9573e0d186170e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleFullScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Toggles the state of <a class="el" href="classQGLViewer.html#a129c439f36bb669672148192abc8ffed">isFullScreen()</a>. See also <a class="el" href="classQGLViewer.html#a7e021e15180ba348e90c955bdd28b1a4">setFullScreen()</a>. </p>

</div>
</div>
<a class="anchor" id="a8dfaa8be71152ae881b9347235ccc6a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleGridIsDrawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Toggles the state of <a class="el" href="classQGLViewer.html#aee18c56a8321a60771b085a5fe798ee7">gridIsDrawn()</a>. See also <a class="el" href="classQGLViewer.html#ae9dd114195dfdf82e23b5754b7c161de">setGridIsDrawn()</a>. </p>

</div>
</div>
<a class="anchor" id="a4e0ebf98eacbcbad3b094e26d9e35886"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleStereoDisplay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Toggles the state of <a class="el" href="classQGLViewer.html#a2fc4c62e317a0f64c2a943ed11faa337">displaysInStereo()</a>. See <a class="el" href="classQGLViewer.html#afe362ba5c3851a93f23fb833b2479f08">setStereoDisplay()</a>. </p>

</div>
</div>
<a class="anchor" id="ab92b2b41db85e4347675b0bc453366d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void toggleTextIsEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Toggles the state of <a class="el" href="classQGLViewer.html#a87896d67f84ddb458e1e5ab326db2631">textIsEnabled()</a>. See also <a class="el" href="classQGLViewer.html#a73d76caa402acd217e504d0bcd13e421">setTextIsEnabled()</a>. </p>

</div>
</div>
<a class="anchor" id="ae12b7378efbffabc24a133ca1deb19ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void updateGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the display. Do not call <a class="el" href="classQGLViewer.html#abc45d04e5f5ce1fbd68f920fcdb2d0e0">draw()</a> directly, use this method instead. See QGLWidget documentation. </p>

</div>
</div>
<a class="anchor" id="a252b68caec768d882a3fa78ecd1499db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void viewerInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal emitted by the default <a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">init()</a> method.</p>
<p>Connect this signal to the methods that need to be called to initialize your viewer or overload <a class="el" href="classQGLViewer.html#a9339772ec5ac9fa929938109207f2863">init()</a>. </p>

</div>
</div>
<a class="anchor" id="a8d3605551bb140ab0c38c78c55722621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQGLViewer.html#aded669cb17515ea2b5971496f9aef875">QGLViewer::MouseAction</a> wheelAction </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the MouseAction (if any) that is performed when using the wheel, when the <code>modifiers</code> and <code>key</code> keyboard keys are pressed.</p>
<p>Returns NO_MOUSE_ACTION if no such binding has been defined using <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a>.</p>
<p>Same as <a class="el" href="classQGLViewer.html#ab689056381e744de41ccc27383294692">mouseAction()</a>, but for the wheel action. See also <a class="el" href="classQGLViewer.html#a783e829b316bac1cb3c7baaff46797e7">wheelHandler()</a>. </p>

</div>
</div>
<a class="anchor" id="abc61c05ed30a94d66ab715c718532c03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wheelEvent </td>
          <td>(</td>
          <td class="paramtype">QWheelEvent *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloading of the <code>QWidget</code> method.</p>
<p>If defined, the wheel event is sent to the <a class="el" href="classQGLViewer.html#a6c834adafd727025b63741dd27cb6925">mouseGrabber()</a>. It is otherwise sent according to wheel bindings (see <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a>). </p>

</div>
</div>
<a class="anchor" id="a783e829b316bac1cb3c7baaff46797e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wheelHandler </td>
          <td>(</td>
          <td class="paramtype">Qt::Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qt::KeyboardModifiers&#160;</td>
          <td class="paramname"><em>modifiers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the MouseHandler (if any) that receives wheel events when the <code>modifiers</code> and <code>key</code> keyboard keys are pressed.</p>
<p>Returns -1 if no no such binding has been defined using <a class="el" href="classQGLViewer.html#a277f432be05de69ae2df05eac8951ad2">setWheelBinding()</a>. See also <a class="el" href="classQGLViewer.html#a8d3605551bb140ab0c38c78c55722621">wheelAction()</a>. </p>

</div>
</div>
<a class="anchor" id="a369399896761e31ae71db57fdd0ba431"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns viewer's widget width (in pixels). See QGLWidget documentation. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 22 2015 16:15:38 for libQGLViewer by &#160;<a href="http://www.doxygen.org/index.html">
doxygen
</a> 1.8.8
</small></address>
</body>
</html>
